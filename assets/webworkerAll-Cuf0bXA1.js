import{D as q,u as K,a as vt,E as R,U as Es,T as Ze,g as Ds,w as at,R as Q,B as Gt,b as O,P as pt,c as Ws,d as W,I as Ls,f as H,h as Rr,M as V,i as E,v as D,j as Hs,n as yt,k as Zt,C as Os,l as X,L as $s,p as Jt,m as Vs,o as Te,e as N}from"./index-BdKXvq5b.js";const te=Object.create(null),Je=Object.create(null);function Fe(i,t){let e=Je[i];return e===void 0&&(te[t]===void 0&&(te[t]=1),Je[i]=e=te[t]++),e}let mt;function Ir(){return(!mt||mt!=null&&mt.isContextLost())&&(mt=q.get().createCanvas().getContext("webgl",{})),mt}let Wt;function Ns(){if(!Wt){Wt="mediump";const i=Ir();i&&i.getShaderPrecisionFormat&&(Wt=i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.HIGH_FLOAT).precision?"highp":"mediump")}return Wt}function js(i,t,e){return t?i:e?(i=i.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `}function Ys(i,t,e){const r=e?t.maxSupportedFragmentPrecision:t.maxSupportedVertexPrecision;if(i.substring(0,9)!=="precision"){let s=e?t.requestedFragmentPrecision:t.requestedVertexPrecision;return s==="highp"&&r!=="highp"&&(s="mediump"),`precision ${s} float;
${i}`}else if(r!=="highp"&&i.substring(0,15)==="precision highp")return i.replace("precision highp","precision mediump");return i}function Xs(i,t){return t?`#version 300 es
${i}`:i}const qs={},Ks={};function Qs(i,{name:t="pixi-program"},e=!0){t=t.replace(/\s+/g,"-"),t+=e?"-fragment":"-vertex";const r=e?qs:Ks;return r[t]?(r[t]++,t+=`-${r[t]}`):r[t]=1,i.indexOf("#define SHADER_NAME")!==-1?i:`${`#define SHADER_NAME ${t}`}
${i}`}function Zs(i,t){return t?i.replace("#version 300 es",""):i}const ee={stripVersion:Zs,ensurePrecision:Ys,addProgramDefines:js,setProgramName:Qs,insertVersion:Xs},re=Object.create(null),zr=class ve{constructor(t){t={...ve.defaultOptions,...t};const e=t.fragment.indexOf("#version 300 es")!==-1,r={stripVersion:e,ensurePrecision:{requestedFragmentPrecision:t.preferredFragmentPrecision,requestedVertexPrecision:t.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:Ns()},setProgramName:{name:t.name},addProgramDefines:e,insertVersion:e};let s=t.fragment,n=t.vertex;Object.keys(ee).forEach(a=>{const o=r[a];s=ee[a](s,o,!0),n=ee[a](n,o,!1)}),this.fragment=s,this.vertex=n,this._key=Fe(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(t){const e=`${t.vertex}:${t.fragment}`;return re[e]||(re[e]=new ve(t)),re[e]}};zr.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let Gr=zr;const tr={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function Js(i){return tr[i]??tr.float32}const ti={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function ei({source:i,entryPoint:t}){const e={},r=i.indexOf(`fn ${t}`);if(r!==-1){const s=i.indexOf("->",r);if(s!==-1){const n=i.substring(r,s),a=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let o;for(;(o=a.exec(n))!==null;){const h=ti[o[3]]??"float32";e[o[2]]={location:parseInt(o[1],10),format:h,stride:Js(h).stride,offset:0,instance:!1,start:0}}}}return e}function se(i){var u,d;const t=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,e=/@group\((\d+)\)/,r=/@binding\((\d+)\)/,s=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,a=/struct\s+(\w+)\s*{([^}]+)}/g,o=/(\w+)\s*:\s*([\w\<\>]+)/g,h=/struct\s+(\w+)/,l=(u=i.match(t))==null?void 0:u.map(f=>({group:parseInt(f.match(e)[1],10),binding:parseInt(f.match(r)[1],10),name:f.match(s)[2],isUniform:f.match(s)[1]==="<uniform>",type:f.match(n)[1]}));if(!l)return{groups:[],structs:[]};const c=((d=i.match(a))==null?void 0:d.map(f=>{const p=f.match(h)[1],m=f.match(o).reduce((g,_)=>{const[x,y]=_.split(":");return g[x.trim()]=y.trim(),g},{});return m?{name:p,members:m}:null}).filter(({name:f})=>l.some(p=>p.type===f)))??[];return{groups:l,structs:c}}var Rt=(i=>(i[i.VERTEX=1]="VERTEX",i[i.FRAGMENT=2]="FRAGMENT",i[i.COMPUTE=4]="COMPUTE",i))(Rt||{});function ri({groups:i}){const t=[];for(let e=0;e<i.length;e++){const r=i[e];t[r.group]||(t[r.group]=[]),r.isUniform?t[r.group].push({binding:r.binding,visibility:Rt.VERTEX|Rt.FRAGMENT,buffer:{type:"uniform"}}):r.type==="sampler"?t[r.group].push({binding:r.binding,visibility:Rt.FRAGMENT,sampler:{type:"filtering"}}):r.type==="texture_2d"&&t[r.group].push({binding:r.binding,visibility:Rt.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return t}function si({groups:i}){const t=[];for(let e=0;e<i.length;e++){const r=i[e];t[r.group]||(t[r.group]={}),t[r.group][r.name]=r.binding}return t}function ii(i,t){const e=new Set,r=new Set,s=[...i.structs,...t.structs].filter(a=>e.has(a.name)?!1:(e.add(a.name),!0)),n=[...i.groups,...t.groups].filter(a=>{const o=`${a.name}-${a.binding}`;return r.has(o)?!1:(r.add(o),!0)});return{structs:s,groups:n}}const ie=Object.create(null);class qt{constructor(t){var o,h;this._layoutKey=0;const{fragment:e,vertex:r,layout:s,gpuLayout:n,name:a}=t;if(this.name=a,this.fragment=e,this.vertex=r,e.source===r.source){const l=se(e.source);this.structsAndGroups=l}else{const l=se(r.source),c=se(e.source);this.structsAndGroups=ii(l,c)}this.layout=s??si(this.structsAndGroups),this.gpuLayout=n??ri(this.structsAndGroups),this.autoAssignGlobalUniforms=((o=this.layout[0])==null?void 0:o.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((h=this.layout[1])==null?void 0:h.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:t,fragment:e}=this,r=t.source+e.source+t.entryPoint+e.entryPoint;this._layoutKey=Fe(r,"program")}get attributeData(){return this._attributeData??(this._attributeData=ei(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(t){const e=`${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;return ie[e]||(ie[e]=new qt(t)),ie[e]}}const Ur=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>"],ni=Ur.reduce((i,t)=>(i[t]=!0,i),{});function ai(i,t){switch(i){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*t);case"vec3<f32>":return new Float32Array(3*t);case"vec4<f32>":return new Float32Array(4*t);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const Er=class Dr{constructor(t,e){this._touched=0,this.uid=K("uniform"),this._resourceType="uniformGroup",this._resourceId=K("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,e={...Dr.defaultOptions,...e},this.uniformStructures=t;const r={};for(const s in t){const n=t[s];if(n.name=s,n.size=n.size??1,!ni[n.type])throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${Ur.join(", ")}`);n.value??(n.value=ai(n.type,n.size)),r[s]=n.value}this.uniforms=r,this._dirtyId=1,this.ubo=e.ubo,this.isStatic=e.isStatic,this._signature=Fe(Object.keys(r).map(s=>`${s}-${t[s].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};Er.defaultOptions={ubo:!1,isStatic:!1};let gt=Er;class _t{constructor(t){this.resources=Object.create(null),this._dirty=!0;let e=0;for(const r in t){const s=t[r];this.setResource(s,e++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const t=[];let e=0;for(const r in this.resources)t[e++]=this.resources[r]._resourceId;this._key=t.join("|")}setResource(t,e){var s,n;const r=this.resources[e];t!==r&&(r&&((s=t.off)==null||s.call(t,"change",this.onResourceChange,this)),(n=t.on)==null||n.call(t,"change",this.onResourceChange,this),this.resources[e]=t,this._dirty=!0)}getResource(t){return this.resources[t]}_touch(t){const e=this.resources;for(const r in e)e[r]._touched=t}destroy(){var e;const t=this.resources;for(const r in t){const s=t[r];(e=s.off)==null||e.call(s,"change",this.onResourceChange,this)}this.resources=null}onResourceChange(t){if(this._dirty=!0,t.destroyed){const e=this.resources;for(const r in e)e[r]===t&&(e[r]=null)}else this._updateKey()}}var bt=(i=>(i[i.WEBGL=1]="WEBGL",i[i.WEBGPU=2]="WEBGPU",i[i.BOTH=3]="BOTH",i))(bt||{});class Kt extends vt{constructor(t){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:e,glProgram:r,groups:s,resources:n,compatibleRenderers:a,groupMap:o}=t;this.gpuProgram=e,this.glProgram=r,a===void 0&&(a=0,e&&(a|=bt.WEBGPU),r&&(a|=bt.WEBGL)),this.compatibleRenderers=a;const h={};if(!n&&!s&&(n={}),n&&s)throw new Error("[Shader] Cannot have both resources and groups");if(!e&&s&&!o)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!e&&s&&o)for(const l in o)for(const c in o[l]){const u=o[l][c];h[u]={group:l,binding:c,name:u}}else if(e&&s&&!o){const l=e.structsAndGroups.groups;o={},l.forEach(c=>{o[c.group]=o[c.group]||{},o[c.group][c.binding]=c.name,h[c.name]=c})}else if(n){if(e){const l=e.structsAndGroups.groups;o={},l.forEach(c=>{o[c.group]=o[c.group]||{},o[c.group][c.binding]=c.name,h[c.name]=c})}else{o={},s={99:new _t},this._ownedBindGroups.push(s[99]);let l=0;for(const c in n)h[c]={group:99,binding:l,name:c},o[99]=o[99]||{},o[99][l]=c,l++}s={};for(const l in n){const c=l;let u=n[l];!u.source&&!u._resourceType&&(u=new gt(u));const d=h[c];d&&(s[d.group]||(s[d.group]=new _t,this._ownedBindGroups.push(s[d.group])),s[d.group].setResource(u,d.binding))}}this.groups=s,this._uniformBindMap=o,this.resources=this._buildResourceAccessor(s,h)}addResource(t,e,r){var s,n;(s=this._uniformBindMap)[e]||(s[e]={}),(n=this._uniformBindMap[e])[r]||(n[r]=t),this.groups[e]||(this.groups[e]=new _t,this._ownedBindGroups.push(this.groups[e]))}_buildResourceAccessor(t,e){const r={};for(const s in e){const n=e[s];Object.defineProperty(r,n.name,{get(){return t[n.group].getResource(n.binding)},set(a){t[n.group].setResource(a,n.binding)}})}return r}destroy(t=!1){var e,r;this.emit("destroy",this),t&&((e=this.gpuProgram)==null||e.destroy(),(r=this.glProgram)==null||r.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(s=>{s.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(t){const{gpu:e,gl:r,...s}=t;let n,a;return e&&(n=qt.from(e)),r&&(a=Gr.from(r)),new Kt({gpuProgram:n,glProgram:a,...s})}}const oi={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},ne=0,ae=1,oe=2,he=3,ce=4,le=5,Pe=class Wr{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<ne)}set blend(t){!!(this.data&1<<ne)!==t&&(this.data^=1<<ne)}get offsets(){return!!(this.data&1<<ae)}set offsets(t){!!(this.data&1<<ae)!==t&&(this.data^=1<<ae)}set cullMode(t){if(t==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=t==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<oe)}set culling(t){!!(this.data&1<<oe)!==t&&(this.data^=1<<oe)}get depthTest(){return!!(this.data&1<<he)}set depthTest(t){!!(this.data&1<<he)!==t&&(this.data^=1<<he)}get depthMask(){return!!(this.data&1<<le)}set depthMask(t){!!(this.data&1<<le)!==t&&(this.data^=1<<le)}get clockwiseFrontFace(){return!!(this.data&1<<ce)}set clockwiseFrontFace(t){!!(this.data&1<<ce)!==t&&(this.data^=1<<ce)}get blendMode(){return this._blendMode}set blendMode(t){this.blend=t!=="none",this._blendMode=t,this._blendModeId=oi[t]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(t){this.offsets=!!t,this._polygonOffset=t}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const t=new Wr;return t.depthTest=!1,t.blend=!0,t}};Pe.default2d=Pe.for2d();let Lr=Pe;class Hr{static init(t){Object.defineProperty(this,"resizeTo",{set(e){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=e,e&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let e,r;if(this._resizeTo===globalThis.window)e=globalThis.innerWidth,r=globalThis.innerHeight;else{const{clientWidth:s,clientHeight:n}=this._resizeTo;e=s,r=n}this.renderer.resize(e,r),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=t.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}Hr.extension=R.Application;class Or{static init(t){t=Object.assign({autoStart:!0,sharedTicker:!1},t),Object.defineProperty(this,"ticker",{set(e){this._ticker&&this._ticker.remove(this.render,this),this._ticker=e,e&&e.add(this.render,this,Es.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=t.sharedTicker?Ze.shared:new Ze,t.autoStart&&this.start()}static destroy(){if(this._ticker){const t=this._ticker;this.ticker=null,t.destroy()}}}Or.extension=R.Application;var hi=li,ue={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},ci=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function li(i){var t=[];return i.replace(ci,function(e,r,s){var n=r.toLowerCase();for(s=di(s),n=="m"&&s.length>2&&(t.push([r].concat(s.splice(0,2))),n="l",r=r=="m"?"l":"L");;){if(s.length==ue[n])return s.unshift(r),t.push(s);if(s.length<ue[n])throw new Error("malformed path data");t.push([r].concat(s.splice(0,ue[n])))}}),t}var ui=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function di(i){var t=i.match(ui);return t?t.map(Number):[]}const fi=Ds(hi);function pi(i,t){const e=fi(i),r=[];let s=null,n=0,a=0;for(let o=0;o<e.length;o++){const h=e[o],l=h[0],c=h;switch(l){case"M":n=c[1],a=c[2],t.moveTo(n,a);break;case"m":n+=c[1],a+=c[2],t.moveTo(n,a);break;case"H":n=c[1],t.lineTo(n,a);break;case"h":n+=c[1],t.lineTo(n,a);break;case"V":a=c[1],t.lineTo(n,a);break;case"v":a+=c[1],t.lineTo(n,a);break;case"L":n=c[1],a=c[2],t.lineTo(n,a);break;case"l":n+=c[1],a+=c[2],t.lineTo(n,a);break;case"C":n=c[5],a=c[6],t.bezierCurveTo(c[1],c[2],c[3],c[4],n,a);break;case"c":t.bezierCurveTo(n+c[1],a+c[2],n+c[3],a+c[4],n+c[5],a+c[6]),n+=c[5],a+=c[6];break;case"S":n=c[3],a=c[4],t.bezierCurveToShort(c[1],c[2],n,a);break;case"s":t.bezierCurveToShort(n+c[1],a+c[2],n+c[3],a+c[4]),n+=c[3],a+=c[4];break;case"Q":n=c[3],a=c[4],t.quadraticCurveTo(c[1],c[2],n,a);break;case"q":t.quadraticCurveTo(n+c[1],a+c[2],n+c[3],a+c[4]),n+=c[3],a+=c[4];break;case"T":n=c[1],a=c[2],t.quadraticCurveToShort(n,a);break;case"t":n+=c[1],a+=c[2],t.quadraticCurveToShort(n,a);break;case"A":n=c[6],a=c[7],t.arcToSvg(c[1],c[2],c[3],c[4],c[5],n,a);break;case"a":n+=c[6],a+=c[7],t.arcToSvg(c[1],c[2],c[3],c[4],c[5],n,a);break;case"Z":case"z":t.closePath(),r.length>0&&(s=r.pop(),s?(n=s.startX,a=s.startY):(n=0,a=0)),s=null;break;default:at(`Unknown SVG path command: ${l}`)}l!=="Z"&&l!=="z"&&s===null&&(s={startX:n,startY:a},r.push(s))}return t}class Re{constructor(t=0,e=0,r=0){this.type="circle",this.x=t,this.y=e,this.radius=r}clone(){return new Re(this.x,this.y,this.radius)}contains(t,e){if(this.radius<=0)return!1;const r=this.radius*this.radius;let s=this.x-t,n=this.y-e;return s*=s,n*=n,s+n<=r}strokeContains(t,e,r){if(this.radius===0)return!1;const s=this.x-t,n=this.y-e,a=this.radius,o=r/2,h=Math.sqrt(s*s+n*n);return h<a+o&&h>a-o}getBounds(t){return t=t||new Q,t.x=this.x-this.radius,t.y=this.y-this.radius,t.width=this.radius*2,t.height=this.radius*2,t}copyFrom(t){return this.x=t.x,this.y=t.y,this.radius=t.radius,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`}}class Ie{constructor(t=0,e=0,r=0,s=0){this.type="ellipse",this.x=t,this.y=e,this.halfWidth=r,this.halfHeight=s}clone(){return new Ie(this.x,this.y,this.halfWidth,this.halfHeight)}contains(t,e){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let r=(t-this.x)/this.halfWidth,s=(e-this.y)/this.halfHeight;return r*=r,s*=s,r+s<=1}strokeContains(t,e,r){const{halfWidth:s,halfHeight:n}=this;if(s<=0||n<=0)return!1;const a=r/2,o=s-a,h=n-a,l=s+a,c=n+a,u=t-this.x,d=e-this.y,f=u*u/(o*o)+d*d/(h*h),p=u*u/(l*l)+d*d/(c*c);return f>1&&p<=1}getBounds(){return new Q(this.x-this.halfWidth,this.y-this.halfHeight,this.halfWidth*2,this.halfHeight*2)}copyFrom(t){return this.x=t.x,this.y=t.y,this.halfWidth=t.halfWidth,this.halfHeight=t.halfHeight,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`}}function gi(i,t,e,r,s,n){const a=i-e,o=t-r,h=s-e,l=n-r,c=a*h+o*l,u=h*h+l*l;let d=-1;u!==0&&(d=c/u);let f,p;d<0?(f=e,p=r):d>1?(f=s,p=n):(f=e+d*h,p=r+d*l);const m=i-f,g=t-p;return m*m+g*g}class It{constructor(...t){this.type="polygon";let e=Array.isArray(t[0])?t[0]:t;if(typeof e[0]!="number"){const r=[];for(let s=0,n=e.length;s<n;s++)r.push(e[s].x,e[s].y);e=r}this.points=e,this.closePath=!0}clone(){const t=this.points.slice(),e=new It(t);return e.closePath=this.closePath,e}contains(t,e){let r=!1;const s=this.points.length/2;for(let n=0,a=s-1;n<s;a=n++){const o=this.points[n*2],h=this.points[n*2+1],l=this.points[a*2],c=this.points[a*2+1];h>e!=c>e&&t<(l-o)*((e-h)/(c-h))+o&&(r=!r)}return r}strokeContains(t,e,r){const s=r/2,n=s*s,{points:a}=this,o=a.length-(this.closePath?0:2);for(let h=0;h<o;h+=2){const l=a[h],c=a[h+1],u=a[(h+2)%a.length],d=a[(h+3)%a.length];if(gi(t,e,l,c,u,d)<=n)return!0}return!1}getBounds(t){t=t||new Q;const e=this.points;let r=1/0,s=-1/0,n=1/0,a=-1/0;for(let o=0,h=e.length;o<h;o+=2){const l=e[o],c=e[o+1];r=l<r?l:r,s=l>s?l:s,n=c<n?c:n,a=c>a?c:a}return t.x=r,t.width=s-r,t.y=n,t.height=a-n,t}copyFrom(t){return this.points=t.points.slice(),this.closePath=t.closePath,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t,e)=>`${t}, ${e}`,"")}]`}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return this.points[this.points.length-2]}get y(){return this.points[this.points.length-1]}}const Lt=(i,t,e,r,s,n)=>{const a=i-e,o=t-r,h=Math.sqrt(a*a+o*o);return h>=s-n&&h<=s+n};class ze{constructor(t=0,e=0,r=0,s=0,n=20){this.type="roundedRectangle",this.x=t,this.y=e,this.width=r,this.height=s,this.radius=n}getBounds(t){return t=t||new Q,t.x=this.x,t.y=this.y,t.width=this.width,t.height=this.height,t}clone(){return new ze(this.x,this.y,this.width,this.height,this.radius)}copyFrom(t){return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this}copyTo(t){return t.copyFrom(this),t}contains(t,e){if(this.width<=0||this.height<=0)return!1;if(t>=this.x&&t<=this.x+this.width&&e>=this.y&&e<=this.y+this.height){const r=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(e>=this.y+r&&e<=this.y+this.height-r||t>=this.x+r&&t<=this.x+this.width-r)return!0;let s=t-(this.x+r),n=e-(this.y+r);const a=r*r;if(s*s+n*n<=a||(s=t-(this.x+this.width-r),s*s+n*n<=a)||(n=e-(this.y+this.height-r),s*s+n*n<=a)||(s=t-(this.x+r),s*s+n*n<=a))return!0}return!1}strokeContains(t,e,r){const{x:s,y:n,width:a,height:o,radius:h}=this,l=r/2,c=s+h,u=n+h,d=a-h*2,f=o-h*2,p=s+a,m=n+o;return(t>=s-l&&t<=s+l||t>=p-l&&t<=p+l)&&e>=u&&e<=u+f||(e>=n-l&&e<=n+l||e>=m-l&&e<=m+l)&&t>=c&&t<=c+d?!0:t<c&&e<u&&Lt(t,e,c,u,h,l)||t>p-h&&e<u&&Lt(t,e,p-h,u,h,l)||t>p-h&&e>m-h&&Lt(t,e,p-h,m-h,h,l)||t<c&&e>m-h&&Lt(t,e,c,m-h,h,l)}toString(){return`[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`}}var L=(i=>(i[i.MAP_READ=1]="MAP_READ",i[i.MAP_WRITE=2]="MAP_WRITE",i[i.COPY_SRC=4]="COPY_SRC",i[i.COPY_DST=8]="COPY_DST",i[i.INDEX=16]="INDEX",i[i.VERTEX=32]="VERTEX",i[i.UNIFORM=64]="UNIFORM",i[i.STORAGE=128]="STORAGE",i[i.INDIRECT=256]="INDIRECT",i[i.QUERY_RESOLVE=512]="QUERY_RESOLVE",i[i.STATIC=1024]="STATIC",i))(L||{});class nt extends vt{constructor(t){let{data:e,size:r}=t;const{usage:s,label:n,shrinkToFit:a}=t;super(),this.uid=K("buffer"),this._resourceType="buffer",this._resourceId=K("resource"),this._touched=0,this._updateID=1,this.shrinkToFit=!0,this.destroyed=!1,e instanceof Array&&(e=new Float32Array(e)),this._data=e,r=r??(e==null?void 0:e.byteLength);const o=!!e;this.descriptor={size:r,usage:s,mappedAtCreation:o,label:n},this.shrinkToFit=a??!0}get data(){return this._data}set data(t){this.setDataWithSize(t,t.length,!0)}get static(){return!!(this.descriptor.usage&L.STATIC)}set static(t){t?this.descriptor.usage|=L.STATIC:this.descriptor.usage&=~L.STATIC}setDataWithSize(t,e,r){if(this._updateID++,this._updateSize=e*t.BYTES_PER_ELEMENT,this._data===t){r&&this.emit("update",this);return}const s=this._data;if(this._data=t,s.length!==t.length){!this.shrinkToFit&&t.byteLength<s.byteLength?r&&this.emit("update",this):(this.descriptor.size=t.byteLength,this._resourceId=K("resource"),this.emit("change",this));return}r&&this.emit("update",this)}update(t){this._updateSize=t??this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function $r(i,t){if(!(i instanceof nt)){let e=t?L.INDEX:L.VERTEX;i instanceof Array&&(t?(i=new Uint32Array(i),e=L.INDEX|L.COPY_DST):(i=new Float32Array(i),e=L.VERTEX|L.COPY_DST)),i=new nt({data:i,label:t?"index-mesh-buffer":"vertex-mesh-buffer",usage:e})}return i}function mi(i,t,e){const r=i.getAttribute(t);if(!r)return e.minX=0,e.minY=0,e.maxX=0,e.maxY=0,e;const s=r.buffer.data;let n=1/0,a=1/0,o=-1/0,h=-1/0;const l=s.BYTES_PER_ELEMENT,c=(r.offset||0)/l,u=(r.stride||2*4)/l;for(let d=c;d<s.length;d+=u){const f=s[d],p=s[d+1];f>o&&(o=f),p>h&&(h=p),f<n&&(n=f),p<a&&(a=p)}return e.minX=n,e.minY=a,e.maxX=o,e.maxY=h,e}function xi(i){return(i instanceof nt||Array.isArray(i)||i.BYTES_PER_ELEMENT)&&(i={buffer:i}),i.buffer=$r(i.buffer,!1),i}class Ge extends vt{constructor(t){const{attributes:e,indexBuffer:r,topology:s}=t;super(),this.uid=K("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new Gt,this._boundsDirty=!0,this.attributes=e,this.buffers=[],this.instanceCount=t.instanceCount||1;for(const n in e){const a=e[n]=xi(e[n]);this.buffers.indexOf(a.buffer)===-1&&(this.buffers.push(a.buffer),a.buffer.on("update",this.onBufferUpdate,this),a.buffer.on("change",this.onBufferUpdate,this))}r&&(this.indexBuffer=$r(r,!0),this.buffers.push(this.indexBuffer)),this.topology=s||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(t){return this.attributes[t]}getIndex(){return this.indexBuffer}getBuffer(t){return this.getAttribute(t).buffer}getSize(){for(const t in this.attributes){const e=this.attributes[t];return e.buffer.data.length/(e.stride/4||e.size)}return 0}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,mi(this,"aPosition",this._bounds)):this._bounds}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners(),t&&this.buffers.forEach(e=>e.destroy()),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}const _i=new Float32Array(1),yi=new Uint32Array(1);class bi extends Ge{constructor(){const e=new nt({data:_i,label:"attribute-batch-buffer",usage:L.VERTEX|L.COPY_DST,shrinkToFit:!1}),r=new nt({data:yi,label:"index-batch-buffer",usage:L.INDEX|L.COPY_DST,shrinkToFit:!1}),s=6*4;super({attributes:{aPosition:{buffer:e,format:"float32x2",stride:s,offset:0,location:1},aUV:{buffer:e,format:"float32x2",stride:s,offset:2*4,location:3},aColor:{buffer:e,format:"unorm8x4",stride:s,offset:4*4,location:0},aTextureIdAndRound:{buffer:e,format:"uint16x2",stride:s,offset:5*4,location:2}},indexBuffer:r})}}let Ht=null;function St(){if(Ht)return Ht;const i=Ir();return Ht=i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),Ht}const Vr={};function Si(i,t){let e=0;for(let r=0;r<t;r++)e=e*31+i[r].uid>>>0;return Vr[e]||wi(i,e)}let de=0;function wi(i,t){const e={};let r=0;de||(de=St());for(let n=0;n<de;n++){const a=n<i.length?i[n]:O.EMPTY.source;e[r++]=a.source,e[r++]=a.style}const s=new _t(e);return Vr[t]=s,s}class er{constructor(t){typeof t=="number"?this.rawBinaryData=new ArrayBuffer(t):t instanceof Uint8Array?this.rawBinaryData=t.buffer:this.rawBinaryData=t,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(t){return this[`${t}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(t){switch(t){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${t} isn't a valid view type`)}}}function rr(i,t){const e=i.byteLength/8|0,r=new Float64Array(i,0,e);new Float64Array(t,0,e).set(r);const n=i.byteLength-e*8;if(n>0){const a=new Uint8Array(i,e*8,n);new Uint8Array(t,e*8,n).set(a)}}const Ti={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};function sr(i,t){return t.alphaMode==="no-premultiply-alpha"&&Ti[i]||i}class ir{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let t=0;t<this.count;t++){const e=this.textures[t];this.textures[t]=null,this.ids[e.uid]=null}this.count=0}}class nr{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.blendMode="normal",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}let At=0;const Nr=class jr{constructor(t={}){this.uid=K("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._vertexSize=6,this._elements=[],this._batchPool=[],this._batchPoolIndex=0,this._textureBatchPool=[],this._textureBatchPoolIndex=0,t={...jr.defaultOptions,...t};const{vertexSize:e,indexSize:r}=t;this.attributeBuffer=new er(e*this._vertexSize*4),this.indexBuffer=new Uint16Array(r),this._maxTextures=St()}begin(){this.batchIndex=0,this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0,this._batchPoolIndex=0,this._textureBatchPoolIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(t){this._elements[this.elementSize++]=t,t.indexStart=this.indexSize,t.location=this.attributeSize,t.batcher=this,this.indexSize+=t.indexSize,this.attributeSize+=t.vertexSize*this._vertexSize}checkAndUpdateTexture(t,e){const r=t.batch.textures.ids[e._source.uid];return!r&&r!==0?!1:(t.textureId=r,t.texture=e,!0)}updateElement(t){this.dirty=!0,t.packAttributes(this.attributeBuffer.float32View,this.attributeBuffer.uint32View,t.location,t.textureId)}break(t){const e=this._elements;let r=this._textureBatchPool[this._textureBatchPoolIndex++]||new ir;if(r.clear(),!e[this.elementStart])return;const s=e[this.elementStart];let n=sr(s.blendMode,s.texture._source);this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const a=this.attributeBuffer.float32View,o=this.attributeBuffer.uint32View,h=this.indexBuffer;let l=this._batchIndexSize,c=this._batchIndexStart,u="startBatch",d=this._batchPool[this._batchPoolIndex++]||new nr;const f=this._maxTextures;for(let p=this.elementStart;p<this.elementSize;++p){const m=e[p];e[p]=null;const _=m.texture._source,x=sr(m.blendMode,_),y=n!==x;if(_._batchTick===At&&!y){m.textureId=_._textureBindLocation,l+=m.indexSize,m.packAttributes(a,o,m.location,m.textureId),m.packIndex(h,m.indexStart,m.location/this._vertexSize),m.batch=d;continue}_._batchTick=At,(r.count>=f||y)&&(this._finishBatch(d,c,l-c,r,n,t,u),u="renderBatch",c=l,n=x,r=this._textureBatchPool[this._textureBatchPoolIndex++]||new ir,r.clear(),d=this._batchPool[this._batchPoolIndex++]||new nr,++At),m.textureId=_._textureBindLocation=r.count,r.ids[_.uid]=r.count,r.textures[r.count++]=_,m.batch=d,l+=m.indexSize,m.packAttributes(a,o,m.location,m.textureId),m.packIndex(h,m.indexStart,m.location/this._vertexSize)}r.count>0&&(this._finishBatch(d,c,l-c,r,n,t,u),c=l,++At),this.elementStart=this.elementSize,this._batchIndexStart=c,this._batchIndexSize=l}_finishBatch(t,e,r,s,n,a,o){t.gpuBindGroup=null,t.action=o,t.batcher=this,t.textures=s,t.blendMode=n,t.start=e,t.size=r,++At,a.add(t)}finish(t){this.break(t)}ensureAttributeBuffer(t){t*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(t*4)}ensureIndexBuffer(t){t<=this.indexBuffer.length||this._resizeIndexBuffer(t)}_resizeAttributeBuffer(t){const e=Math.max(t,this.attributeBuffer.size*2),r=new er(e);rr(this.attributeBuffer.rawBinaryData,r.rawBinaryData),this.attributeBuffer=r}_resizeIndexBuffer(t){const e=this.indexBuffer;let r=Math.max(t,e.length*1.5);r+=r%2;const s=r>65535?new Uint32Array(r):new Uint16Array(r);if(s.BYTES_PER_ELEMENT!==e.BYTES_PER_ELEMENT)for(let n=0;n<e.length;n++)s[n]=e[n];else rr(e.buffer,s.buffer);this.indexBuffer=s}destroy(){for(let t=0;t<this.batches.length;t++)this.batches[t].destroy();this.batches=null;for(let t=0;t<this._elements.length;t++)this._elements[t].batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};Nr.defaultOptions={vertexSize:4,indexSize:6};let vi=Nr;function Pi(i,t,e,r,s,n,a,o=null){let h=0;e*=t,s*=n;const l=o.a,c=o.b,u=o.c,d=o.d,f=o.tx,p=o.ty;for(;h<a;){const m=i[e],g=i[e+1];r[s]=l*m+u*g+f,r[s+1]=c*m+d*g+p,s+=n,e+=t,h++}}function Ci(i,t,e,r){let s=0;for(t*=e;s<r;)i[t]=0,i[t+1]=0,t+=e,s++}function Yr(i,t,e,r,s){const n=t.a,a=t.b,o=t.c,h=t.d,l=t.tx,c=t.ty;e=e||0,r=r||2,s=s||i.length/r-e;let u=e*r;for(let d=0;d<s;d++){const f=i[u],p=i[u+1];i[u]=n*f+o*p+l,i[u+1]=a*f+h*p+c,u+=r}}function Mi(i,t){if(i===16777215||!t)return t;if(t===16777215||!i)return i;const e=i>>16&255,r=i>>8&255,s=i&255,n=t>>16&255,a=t>>8&255,o=t&255,h=e*n/255,l=r*a/255,c=s*o/255;return(h<<16)+(l<<8)+c}class Ue{constructor(){this.batcher=null,this.batch=null,this.applyTransform=!0,this.roundPixels=0}get blendMode(){return this.applyTransform?this.renderable.groupBlendMode:"normal"}packIndex(t,e,r){const s=this.geometryData.indices;for(let n=0;n<this.indexSize;n++)t[e++]=s[n+this.indexOffset]+r-this.vertexOffset}packAttributes(t,e,r,s){const n=this.geometryData,a=this.renderable,o=n.vertices,h=n.uvs,l=this.vertexOffset*2,c=(this.vertexOffset+this.vertexSize)*2,u=this.color,d=u>>16|u&65280|(u&255)<<16;if(this.applyTransform){const f=Mi(d,a.groupColor)+(this.alpha*a.groupAlpha*255<<24),p=a.groupTransform,m=s<<16|this.roundPixels&65535,g=p.a,_=p.b,x=p.c,y=p.d,b=p.tx,P=p.ty;for(let k=l;k<c;k+=2){const T=o[k],v=o[k+1];t[r]=g*T+x*v+b,t[r+1]=_*T+y*v+P,t[r+2]=h[k],t[r+3]=h[k+1],e[r+4]=f,e[r+5]=m,r+=6}}else{const f=d+(this.alpha*255<<24);for(let p=l;p<c;p+=2)t[r]=o[p],t[r+1]=o[p+1],t[r+2]=h[p],t[r+3]=h[p+1],e[r+4]=f,e[r+5]=s<<16,r+=6}}get vertSize(){return this.vertexSize}copyTo(t){t.indexOffset=this.indexOffset,t.indexSize=this.indexSize,t.vertexOffset=this.vertexOffset,t.vertexSize=this.vertexSize,t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.geometryData=this.geometryData}reset(){this.applyTransform=!0}}const fe={build(i,t){let e,r,s,n,a,o;if(i.type==="circle"){const b=i;e=b.x,r=b.y,a=o=b.radius,s=n=0}else if(i.type==="ellipse"){const b=i;e=b.x,r=b.y,a=b.halfWidth,o=b.halfHeight,s=n=0}else{const b=i,P=b.width/2,k=b.height/2;e=b.x+P,r=b.y+k,a=o=Math.max(0,Math.min(b.radius,Math.min(P,k))),s=P-a,n=k-o}if(!(a>=0&&o>=0&&s>=0&&n>=0))return t;const h=Math.ceil(2.3*Math.sqrt(a+o)),l=h*8+(s?4:0)+(n?4:0);if(l===0)return t;if(h===0)return t[0]=t[6]=e+s,t[1]=t[3]=r+n,t[2]=t[4]=e-s,t[5]=t[7]=r-n,t;let c=0,u=h*4+(s?2:0)+2,d=u,f=l,p=s+a,m=n,g=e+p,_=e-p,x=r+m;if(t[c++]=g,t[c++]=x,t[--u]=x,t[--u]=_,n){const b=r-m;t[d++]=_,t[d++]=b,t[--f]=b,t[--f]=g}for(let b=1;b<h;b++){const P=Math.PI/2*(b/h),k=s+Math.cos(P)*a,T=n+Math.sin(P)*o,v=e+k,S=e-k,w=r+T,G=r-T;t[c++]=v,t[c++]=w,t[--u]=w,t[--u]=S,t[d++]=S,t[d++]=G,t[--f]=G,t[--f]=v}p=s,m=n+o,g=e+p,_=e-p,x=r+m;const y=r-m;return t[c++]=g,t[c++]=x,t[--f]=y,t[--f]=g,s&&(t[c++]=_,t[c++]=x,t[--f]=y,t[--f]=_),t},triangulate(i,t,e,r,s,n){if(i.length===0)return;let a=0,o=0;for(let c=0;c<i.length;c+=2)a+=i[c],o+=i[c+1];a/=i.length/2,o/=i.length/2;let h=r;t[h*e]=a,t[h*e+1]=o;const l=h++;for(let c=0;c<i.length;c+=2)t[h*e]=i[c],t[h*e+1]=i[c+1],c>0&&(s[n++]=h,s[n++]=l,s[n++]=h-1),h++;s[n++]=l+1,s[n++]=l,s[n++]=h-1}},ki=1e-4,ar=1e-4;function Bi(i){const t=i.length;if(t<6)return 1;let e=0;for(let r=0,s=i[t-2],n=i[t-1];r<t;r+=2){const a=i[r],o=i[r+1];e+=(a-s)*(o+n),s=a,n=o}return e<0?-1:1}function or(i,t,e,r,s,n,a,o){const h=i-e*s,l=t-r*s,c=i+e*n,u=t+r*n;let d,f;a?(d=r,f=-e):(d=-r,f=e);const p=h+d,m=l+f,g=c+d,_=u+f;return o.push(p,m),o.push(g,_),2}function ut(i,t,e,r,s,n,a,o){const h=e-i,l=r-t;let c=Math.atan2(h,l),u=Math.atan2(s-i,n-t);o&&c<u?c+=Math.PI*2:!o&&c>u&&(u+=Math.PI*2);let d=c;const f=u-c,p=Math.abs(f),m=Math.sqrt(h*h+l*l),g=(15*p*Math.sqrt(m)/Math.PI>>0)+1,_=f/g;if(d+=_,o){a.push(i,t),a.push(e,r);for(let x=1,y=d;x<g;x++,y+=_)a.push(i,t),a.push(i+Math.sin(y)*m,t+Math.cos(y)*m);a.push(i,t),a.push(s,n)}else{a.push(e,r),a.push(i,t);for(let x=1,y=d;x<g;x++,y+=_)a.push(i+Math.sin(y)*m,t+Math.cos(y)*m),a.push(i,t);a.push(s,n),a.push(i,t)}return g*2}function Ai(i,t,e,r,s,n,a,o,h){const l=ki;if(i.length===0)return;const c=t;let u=c.alignment;if(t.alignment!==.5){let z=Bi(i);u=(u-.5)*z+.5}const d=new pt(i[0],i[1]),f=new pt(i[i.length-2],i[i.length-1]),p=r,m=Math.abs(d.x-f.x)<l&&Math.abs(d.y-f.y)<l;if(p){i=i.slice(),m&&(i.pop(),i.pop(),f.set(i[i.length-2],i[i.length-1]));const z=(d.x+f.x)*.5,rt=(f.y+d.y)*.5;i.unshift(z,rt),i.push(z,rt)}const g=s,_=i.length/2;let x=i.length;const y=g.length/2,b=c.width/2,P=b*b,k=c.miterLimit*c.miterLimit;let T=i[0],v=i[1],S=i[2],w=i[3],G=0,Y=0,B=-(v-w),C=T-S,I=0,U=0,j=Math.sqrt(B*B+C*C);B/=j,C/=j,B*=b,C*=b;const Pt=u,A=(1-Pt)*2,F=Pt*2;p||(c.cap==="round"?x+=ut(T-B*(A-F)*.5,v-C*(A-F)*.5,T-B*A,v-C*A,T+B*F,v+C*F,g,!0)+2:c.cap==="square"&&(x+=or(T,v,B,C,A,F,!0,g))),g.push(T-B*A,v-C*A),g.push(T+B*F,v+C*F);for(let z=1;z<_-1;++z){T=i[(z-1)*2],v=i[(z-1)*2+1],S=i[z*2],w=i[z*2+1],G=i[(z+1)*2],Y=i[(z+1)*2+1],B=-(v-w),C=T-S,j=Math.sqrt(B*B+C*C),B/=j,C/=j,B*=b,C*=b,I=-(w-Y),U=S-G,j=Math.sqrt(I*I+U*U),I/=j,U/=j,I*=b,U*=b;const rt=S-T,Ct=v-w,Mt=S-G,kt=Y-w,Xe=rt*Mt+Ct*kt,Ut=Ct*Mt-kt*rt,Bt=Ut<0;if(Math.abs(Ut)<.001*Math.abs(Xe)){g.push(S-B*A,w-C*A),g.push(S+B*F,w+C*F),Xe>=0&&(c.join==="round"?x+=ut(S,w,S-B*A,w-C*A,S-I*A,w-U*A,g,!1)+4:x+=2,g.push(S-I*F,w-U*F),g.push(S+I*A,w+U*A));continue}const qe=(-B+T)*(-C+w)-(-B+S)*(-C+v),Ke=(-I+G)*(-U+w)-(-I+S)*(-U+Y),Et=(rt*Ke-Mt*qe)/Ut,Dt=(kt*qe-Ct*Ke)/Ut,Qt=(Et-S)*(Et-S)+(Dt-w)*(Dt-w),ot=S+(Et-S)*A,ht=w+(Dt-w)*A,ct=S-(Et-S)*F,lt=w-(Dt-w)*F,Gs=Math.min(rt*rt+Ct*Ct,Mt*Mt+kt*kt),Qe=Bt?A:F,Us=Gs+Qe*Qe*P;Qt<=Us?c.join==="bevel"||Qt/P>k?(Bt?(g.push(ot,ht),g.push(S+B*F,w+C*F),g.push(ot,ht),g.push(S+I*F,w+U*F)):(g.push(S-B*A,w-C*A),g.push(ct,lt),g.push(S-I*A,w-U*A),g.push(ct,lt)),x+=2):c.join==="round"?Bt?(g.push(ot,ht),g.push(S+B*F,w+C*F),x+=ut(S,w,S+B*F,w+C*F,S+I*F,w+U*F,g,!0)+4,g.push(ot,ht),g.push(S+I*F,w+U*F)):(g.push(S-B*A,w-C*A),g.push(ct,lt),x+=ut(S,w,S-B*A,w-C*A,S-I*A,w-U*A,g,!1)+4,g.push(S-I*A,w-U*A),g.push(ct,lt)):(g.push(ot,ht),g.push(ct,lt)):(g.push(S-B*A,w-C*A),g.push(S+B*F,w+C*F),c.join==="round"?Bt?x+=ut(S,w,S+B*F,w+C*F,S+I*F,w+U*F,g,!0)+2:x+=ut(S,w,S-B*A,w-C*A,S-I*A,w-U*A,g,!1)+2:c.join==="miter"&&Qt/P<=k&&(Bt?(g.push(ct,lt),g.push(ct,lt)):(g.push(ot,ht),g.push(ot,ht)),x+=2),g.push(S-I*A,w-U*A),g.push(S+I*F,w+U*F),x+=2)}T=i[(_-2)*2],v=i[(_-2)*2+1],S=i[(_-1)*2],w=i[(_-1)*2+1],B=-(v-w),C=T-S,j=Math.sqrt(B*B+C*C),B/=j,C/=j,B*=b,C*=b,g.push(S-B*A,w-C*A),g.push(S+B*F,w+C*F),p||(c.cap==="round"?x+=ut(S-B*(A-F)*.5,w-C*(A-F)*.5,S-B*A,w-C*A,S+B*F,w+C*F,g,!1)+2:c.cap==="square"&&(x+=or(S,w,B,C,A,F,!1,g)));const zs=ar*ar;for(let z=y;z<x+y-2;++z)T=g[z*2],v=g[z*2+1],S=g[(z+1)*2],w=g[(z+1)*2+1],G=g[(z+2)*2],Y=g[(z+2)*2+1],!(Math.abs(T*(w-Y)+S*(Y-v)+G*(v-w))<zs)&&o.push(z,z+1,z+2)}function Xr(i,t,e,r,s,n,a){const o=Ws(i,t,2);if(!o)return;for(let l=0;l<o.length;l+=3)n[a++]=o[l]+s,n[a++]=o[l+1]+s,n[a++]=o[l+2]+s;let h=s*r;for(let l=0;l<i.length;l+=2)e[h]=i[l],e[h+1]=i[l+1],h+=r}const Fi=[],Ri={build(i,t){for(let e=0;e<i.points.length;e++)t[e]=i.points[e];return t},triangulate(i,t,e,r,s,n){Xr(i,Fi,t,e,r,s,n)}},Ii={build(i,t){const e=i,r=e.x,s=e.y,n=e.width,a=e.height;return n>=0&&a>=0&&(t[0]=r,t[1]=s,t[2]=r+n,t[3]=s,t[4]=r+n,t[5]=s+a,t[6]=r,t[7]=s+a),t},triangulate(i,t,e,r,s,n){let a=0;r*=e,t[r+a]=i[0],t[r+a+1]=i[1],a+=e,t[r+a]=i[2],t[r+a+1]=i[3],a+=e,t[r+a]=i[6],t[r+a+1]=i[7],a+=e,t[r+a]=i[4],t[r+a+1]=i[5],a+=e;const o=r/e;s[n++]=o,s[n++]=o+1,s[n++]=o+2,s[n++]=o+1,s[n++]=o+3,s[n++]=o+2}},zi={build(i,t){return t[0]=i.x,t[1]=i.y,t[2]=i.x2,t[3]=i.y2,t[4]=i.x3,t[5]=i.y3,t},triangulate(i,t,e,r,s,n){let a=0;r*=e,t[r+a]=i[0],t[r+a+1]=i[1],a+=e,t[r+a]=i[2],t[r+a+1]=i[3],a+=e,t[r+a]=i[4],t[r+a+1]=i[5];const o=r/e;s[n++]=o,s[n++]=o+1,s[n++]=o+2}},Ee={rectangle:Ii,polygon:Ri,triangle:zi,circle:fe,ellipse:fe,roundedRectangle:fe},Gi=new Q;function Ui(i,t){const{geometryData:e,batches:r}=t;r.length=0,e.indices.length=0,e.vertices.length=0,e.uvs.length=0;for(let s=0;s<i.instructions.length;s++){const n=i.instructions[s];if(n.action==="texture")Ei(n.data,r,e);else if(n.action==="fill"||n.action==="stroke"){const a=n.action==="stroke",o=n.data.path.shapePath,h=n.data.style,l=n.data.hole;a&&l&&hr(l.shapePath,h,null,!0,r,e),hr(o,h,l,a,r,e)}}}function Ei(i,t,e){const{vertices:r,uvs:s,indices:n}=e,a=n.length,o=r.length/2,h=[],l=Ee.rectangle,c=Gi,u=i.image;c.x=i.dx,c.y=i.dy,c.width=i.dw,c.height=i.dh;const d=i.transform;l.build(c,h),d&&Yr(h,d),l.triangulate(h,r,2,o,n,a);const f=u.uvs;s.push(f.x0,f.y0,f.x1,f.y1,f.x3,f.y3,f.x2,f.y2);const p=W.get(Ue);p.indexOffset=a,p.indexSize=n.length-a,p.vertexOffset=o,p.vertexSize=r.length/2-o,p.color=i.style,p.alpha=i.alpha,p.texture=u,p.geometryData=e,t.push(p)}function hr(i,t,e,r,s,n){const{vertices:a,uvs:o,indices:h}=n,l=i.shapePrimitives.length-1;i.shapePrimitives.forEach(({shape:c,transform:u},d)=>{const f=h.length,p=a.length/2,m=[],g=Ee[c.type];if(g.build(c,m),u&&Yr(m,u),r){const b=c.closePath??!0;Ai(m,t,!1,b,a,2,p,h)}else if(e&&l===d){l!==0&&console.warn("[Pixi Graphics] only the last shape have be cut out");const b=[],P=m.slice();Di(e.shapePath).forEach(T=>{b.push(P.length/2),P.push(...T)}),Xr(P,b,a,2,p,h,f)}else g.triangulate(m,a,2,p,h,f);const _=o.length/2,x=t.texture;if(x!==O.WHITE){const b=t.matrix;u&&b.append(u.clone().invert()),Pi(a,2,p,o,_,2,a.length/2-p,b)}else Ci(o,_,2,a.length/2-p);const y=W.get(Ue);y.indexOffset=f,y.indexSize=h.length-f,y.vertexOffset=p,y.vertexSize=a.length/2-p,y.color=t.color,y.alpha=t.alpha,y.texture=x,y.geometryData=n,s.push(y)})}function Di(i){if(!i)return[];const t=i.shapePrimitives,e=[];for(let r=0;r<t.length;r++){const s=t[r].shape,n=[];Ee[s.type].build(s,n),e.push(n)}return e}class Wi{constructor(){this.batches=[],this.geometryData={vertices:[],uvs:[],indices:[]}}}class Li{constructor(){this.geometry=new bi,this.instructions=new Ls}init(){this.instructions.reset()}}const De=class Ce{constructor(){this._activeBatchers=[],this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null)}init(t){Ce.defaultOptions.bezierSmoothness=(t==null?void 0:t.bezierSmoothness)??Ce.defaultOptions.bezierSmoothness}prerender(){this._returnActiveBatchers()}getContextRenderData(t){return this._graphicsDataContextHash[t.uid]||this._initContextRenderData(t)}updateGpuContext(t){let e=this._gpuContextHash[t.uid]||this._initContext(t);if(t.dirty){e?this._cleanGraphicsContextData(t):e=this._initContext(t),Ui(t,e);const r=t.batchMode;t.customShader||r==="no-batch"?e.isBatchable=!1:r==="auto"&&(e.isBatchable=e.geometryData.vertices.length<400),t.dirty=!1}return e}getGpuContext(t){return this._gpuContextHash[t.uid]||this._initContext(t)}_returnActiveBatchers(){for(let t=0;t<this._activeBatchers.length;t++)W.return(this._activeBatchers[t]);this._activeBatchers.length=0}_initContextRenderData(t){const e=W.get(Li),{batches:r,geometryData:s}=this._gpuContextHash[t.uid],n=s.vertices.length,a=s.indices.length;for(let c=0;c<r.length;c++)r[c].applyTransform=!1;const o=W.get(vi);this._activeBatchers.push(o),o.ensureAttributeBuffer(n),o.ensureIndexBuffer(a),o.begin();for(let c=0;c<r.length;c++){const u=r[c];o.add(u)}o.finish(e.instructions);const h=e.geometry;h.indexBuffer.setDataWithSize(o.indexBuffer,o.indexSize,!0),h.buffers[0].setDataWithSize(o.attributeBuffer.float32View,o.attributeSize,!0);const l=o.batches;for(let c=0;c<l.length;c++){const u=l[c];u.bindGroup=Si(u.textures.textures,u.textures.count)}return this._graphicsDataContextHash[t.uid]=e,e}_initContext(t){const e=new Wi;return e.context=t,this._gpuContextHash[t.uid]=e,t.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[t.uid]}onGraphicsContextDestroy(t){this._cleanGraphicsContextData(t),t.off("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[t.uid]=null}_cleanGraphicsContextData(t){const e=this._gpuContextHash[t.uid];e.isBatchable||this._graphicsDataContextHash[t.uid]&&(W.return(this.getContextRenderData(t)),this._graphicsDataContextHash[t.uid]=null),e.batches&&e.batches.forEach(r=>{W.return(r)})}destroy(){for(const t in this._gpuContextHash)this._gpuContextHash[t]&&this.onGraphicsContextDestroy(this._gpuContextHash[t].context)}};De.extension={type:[R.WebGLSystem,R.WebGPUSystem,R.CanvasSystem],name:"graphicsContext"};De.defaultOptions={bezierSmoothness:.5};let We=De;const Hi=8,Ot=11920929e-14,Oi=1;function qr(i,t,e,r,s,n,a,o,h,l){const u=Math.min(.99,Math.max(0,l??We.defaultOptions.bezierSmoothness));let d=(Oi-u)/1;return d*=d,$i(t,e,r,s,n,a,o,h,i,d),i}function $i(i,t,e,r,s,n,a,o,h,l){Me(i,t,e,r,s,n,a,o,h,l,0),h.push(a,o)}function Me(i,t,e,r,s,n,a,o,h,l,c){if(c>Hi)return;const u=(i+e)/2,d=(t+r)/2,f=(e+s)/2,p=(r+n)/2,m=(s+a)/2,g=(n+o)/2,_=(u+f)/2,x=(d+p)/2,y=(f+m)/2,b=(p+g)/2,P=(_+y)/2,k=(x+b)/2;if(c>0){let T=a-i,v=o-t;const S=Math.abs((e-a)*v-(r-o)*T),w=Math.abs((s-a)*v-(n-o)*T);if(S>Ot&&w>Ot){if((S+w)*(S+w)<=l*(T*T+v*v)){h.push(P,k);return}}else if(S>Ot){if(S*S<=l*(T*T+v*v)){h.push(P,k);return}}else if(w>Ot){if(w*w<=l*(T*T+v*v)){h.push(P,k);return}}else if(T=P-(i+a)/2,v=k-(t+o)/2,T*T+v*v<=l){h.push(P,k);return}}Me(i,t,u,d,_,x,P,k,h,l,c+1),Me(P,k,y,b,m,g,a,o,h,l,c+1)}const Vi=8,Ni=11920929e-14,ji=1;function Yi(i,t,e,r,s,n,a,o){const l=Math.min(.99,Math.max(0,o??We.defaultOptions.bezierSmoothness));let c=(ji-l)/1;return c*=c,Xi(t,e,r,s,n,a,i,c),i}function Xi(i,t,e,r,s,n,a,o){ke(a,i,t,e,r,s,n,o,0),a.push(s,n)}function ke(i,t,e,r,s,n,a,o,h){if(h>Vi)return;const l=(t+r)/2,c=(e+s)/2,u=(r+n)/2,d=(s+a)/2,f=(l+u)/2,p=(c+d)/2;let m=n-t,g=a-e;const _=Math.abs((r-n)*g-(s-a)*m);if(_>Ni){if(_*_<=o*(m*m+g*g)){i.push(f,p);return}}else if(m=f-(t+n)/2,g=p-(e+a)/2,m*m+g*g<=o){i.push(f,p);return}ke(i,t,e,l,c,f,p,o,h+1),ke(i,f,p,u,d,n,a,o,h+1)}function Kr(i,t,e,r,s,n,a,o){let h=Math.abs(s-n);(!a&&s>n||a&&n>s)&&(h=2*Math.PI-h),o=o||Math.max(6,Math.floor(6*Math.pow(r,1/3)*(h/Math.PI))),o=Math.max(o,3);let l=h/o,c=s;l*=a?-1:1;for(let u=0;u<o+1;u++){const d=Math.cos(c),f=Math.sin(c),p=t+d*r,m=e+f*r;i.push(p,m),c+=l}}function qi(i,t,e,r,s,n){const a=i[i.length-2],h=i[i.length-1]-e,l=a-t,c=s-e,u=r-t,d=Math.abs(h*u-l*c);if(d<1e-8||n===0){(i[i.length-2]!==t||i[i.length-1]!==e)&&i.push(t,e);return}const f=h*h+l*l,p=c*c+u*u,m=h*c+l*u,g=n*Math.sqrt(f)/d,_=n*Math.sqrt(p)/d,x=g*m/f,y=_*m/p,b=g*u+_*l,P=g*c+_*h,k=l*(_+x),T=h*(_+x),v=u*(g+y),S=c*(g+y),w=Math.atan2(T-P,k-b),G=Math.atan2(S-P,v-b);Kr(i,b+t,P+e,n,w,G,l*c>u*h)}const zt=Math.PI*2,pe={centerX:0,centerY:0,ang1:0,ang2:0},ge=({x:i,y:t},e,r,s,n,a,o,h)=>{i*=e,t*=r;const l=s*i-n*t,c=n*i+s*t;return h.x=l+a,h.y=c+o,h};function Ki(i,t){const e=t===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(t/4),r=t===1.5707963267948966?.551915024494:e,s=Math.cos(i),n=Math.sin(i),a=Math.cos(i+t),o=Math.sin(i+t);return[{x:s-n*r,y:n+s*r},{x:a+o*r,y:o-a*r},{x:a,y:o}]}const cr=(i,t,e,r)=>{const s=i*r-t*e<0?-1:1;let n=i*e+t*r;return n>1&&(n=1),n<-1&&(n=-1),s*Math.acos(n)},Qi=(i,t,e,r,s,n,a,o,h,l,c,u,d)=>{const f=Math.pow(s,2),p=Math.pow(n,2),m=Math.pow(c,2),g=Math.pow(u,2);let _=f*p-f*g-p*m;_<0&&(_=0),_/=f*g+p*m,_=Math.sqrt(_)*(a===o?-1:1);const x=_*s/n*u,y=_*-n/s*c,b=l*x-h*y+(i+e)/2,P=h*x+l*y+(t+r)/2,k=(c-x)/s,T=(u-y)/n,v=(-c-x)/s,S=(-u-y)/n,w=cr(1,0,k,T);let G=cr(k,T,v,S);o===0&&G>0&&(G-=zt),o===1&&G<0&&(G+=zt),d.centerX=b,d.centerY=P,d.ang1=w,d.ang2=G};function Zi(i,t,e,r,s,n,a,o=0,h=0,l=0){if(n===0||a===0)return;const c=Math.sin(o*zt/360),u=Math.cos(o*zt/360),d=u*(t-r)/2+c*(e-s)/2,f=-c*(t-r)/2+u*(e-s)/2;if(d===0&&f===0)return;n=Math.abs(n),a=Math.abs(a);const p=Math.pow(d,2)/Math.pow(n,2)+Math.pow(f,2)/Math.pow(a,2);p>1&&(n*=Math.sqrt(p),a*=Math.sqrt(p)),Qi(t,e,r,s,n,a,h,l,c,u,d,f,pe);let{ang1:m,ang2:g}=pe;const{centerX:_,centerY:x}=pe;let y=Math.abs(g)/(zt/4);Math.abs(1-y)<1e-7&&(y=1);const b=Math.max(Math.ceil(y),1);g/=b;let P=i[i.length-2],k=i[i.length-1];const T={x:0,y:0};for(let v=0;v<b;v++){const S=Ki(m,g),{x:w,y:G}=ge(S[0],n,a,u,c,_,x,T),{x:Y,y:B}=ge(S[1],n,a,u,c,_,x,T),{x:C,y:I}=ge(S[2],n,a,u,c,_,x,T);qr(i,P,k,w,G,Y,B,C,I),P=C,k=I,m+=g}}function Ji(i,t,e){const r=(a,o)=>{const h=o.x-a.x,l=o.y-a.y,c=Math.sqrt(h*h+l*l),u=h/c,d=l/c;return{len:c,nx:u,ny:d}},s=(a,o)=>{a===0?i.moveTo(o.x,o.y):i.lineTo(o.x,o.y)};let n=t[t.length-1];for(let a=0;a<t.length;a++){const o=t[a%t.length],h=o.radius??e;if(h<=0){s(a,o),n=o;continue}const l=t[(a+1)%t.length],c=r(o,n),u=r(o,l);if(c.len<1e-4||u.len<1e-4){s(a,o),n=o;continue}let d=Math.asin(c.nx*u.ny-c.ny*u.nx),f=1,p=!1;c.nx*u.nx-c.ny*-u.ny<0?d<0?d=Math.PI+d:(d=Math.PI-d,f=-1,p=!0):d>0&&(f=-1,p=!0);const m=d/2;let g,_=Math.abs(Math.cos(m)*h/Math.sin(m));_>Math.min(c.len/2,u.len/2)?(_=Math.min(c.len/2,u.len/2),g=Math.abs(_*Math.sin(m)/Math.cos(m))):g=h;const x=o.x+u.nx*_+-u.ny*g*f,y=o.y+u.ny*_+u.nx*g*f,b=Math.atan2(c.ny,c.nx)+Math.PI/2*f,P=Math.atan2(u.ny,u.nx)-Math.PI/2*f;a===0&&i.moveTo(x+Math.cos(b)*g,y+Math.sin(b)*g),i.arc(x,y,g,b,P,p),n=o}}function tn(i,t,e,r){const s=(o,h)=>Math.sqrt((o.x-h.x)**2+(o.y-h.y)**2),n=(o,h,l)=>({x:o.x+(h.x-o.x)*l,y:o.y+(h.y-o.y)*l}),a=t.length;for(let o=0;o<a;o++){const h=t[(o+1)%a],l=h.radius??e;if(l<=0){o===0?i.moveTo(h.x,h.y):i.lineTo(h.x,h.y);continue}const c=t[o],u=t[(o+2)%a],d=s(c,h);let f;if(d<1e-4)f=h;else{const g=Math.min(d/2,l);f=n(h,c,g/d)}const p=s(u,h);let m;if(p<1e-4)m=h;else{const g=Math.min(p/2,l);m=n(h,u,g/p)}o===0?i.moveTo(f.x,f.y):i.lineTo(f.x,f.y),i.quadraticCurveTo(h.x,h.y,m.x,m.y,r)}}const en=new Q;class rn{constructor(t){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new Gt,this._graphicsPath2D=t}moveTo(t,e){return this.startPoly(t,e),this}lineTo(t,e){this._ensurePoly();const r=this._currentPoly.points,s=r[r.length-2],n=r[r.length-1];return(s!==t||n!==e)&&r.push(t,e),this}arc(t,e,r,s,n,a){this._ensurePoly(!1);const o=this._currentPoly.points;return Kr(o,t,e,r,s,n,a),this}arcTo(t,e,r,s,n){this._ensurePoly();const a=this._currentPoly.points;return qi(a,t,e,r,s,n),this}arcToSvg(t,e,r,s,n,a,o){const h=this._currentPoly.points;return Zi(h,this._currentPoly.lastX,this._currentPoly.lastY,a,o,t,e,r,s,n),this}bezierCurveTo(t,e,r,s,n,a,o){this._ensurePoly();const h=this._currentPoly;return qr(this._currentPoly.points,h.lastX,h.lastY,t,e,r,s,n,a,o),this}quadraticCurveTo(t,e,r,s,n){this._ensurePoly();const a=this._currentPoly;return Yi(this._currentPoly.points,a.lastX,a.lastY,t,e,r,s,n),this}closePath(){return this.endPoly(!0),this}addPath(t,e){this.endPoly(),e&&!e.isIdentity()&&(t=t.clone(!0),t.transform(e));for(let r=0;r<t.instructions.length;r++){const s=t.instructions[r];this[s.action](...s.data)}return this}finish(t=!1){this.endPoly(t)}rect(t,e,r,s,n){return this.drawShape(new Q(t,e,r,s),n),this}circle(t,e,r,s){return this.drawShape(new Re(t,e,r),s),this}poly(t,e,r){const s=new It(t);return s.closePath=e,this.drawShape(s,r),this}regularPoly(t,e,r,s,n=0,a){s=Math.max(s|0,3);const o=-1*Math.PI/2+n,h=Math.PI*2/s,l=[];for(let c=0;c<s;c++){const u=c*h+o;l.push(t+r*Math.cos(u),e+r*Math.sin(u))}return this.poly(l,!0,a),this}roundPoly(t,e,r,s,n,a=0,o){if(s=Math.max(s|0,3),n<=0)return this.regularPoly(t,e,r,s,a);const h=r*Math.sin(Math.PI/s)-.001;n=Math.min(n,h);const l=-1*Math.PI/2+a,c=Math.PI*2/s,u=(s-2)*Math.PI/s/2;for(let d=0;d<s;d++){const f=d*c+l,p=t+r*Math.cos(f),m=e+r*Math.sin(f),g=f+Math.PI+u,_=f-Math.PI-u,x=p+n*Math.cos(g),y=m+n*Math.sin(g),b=p+n*Math.cos(_),P=m+n*Math.sin(_);d===0?this.moveTo(x,y):this.lineTo(x,y),this.quadraticCurveTo(p,m,b,P,o)}return this.closePath()}roundShape(t,e,r=!1,s){return t.length<3?this:(r?tn(this,t,e,s):Ji(this,t,e),this.closePath())}filletRect(t,e,r,s,n){if(n===0)return this.rect(t,e,r,s);const a=Math.min(r,s)/2,o=Math.min(a,Math.max(-a,n)),h=t+r,l=e+s,c=o<0?-o:0,u=Math.abs(o);return this.moveTo(t,e+u).arcTo(t+c,e+c,t+u,e,u).lineTo(h-u,e).arcTo(h-c,e+c,h,e+u,u).lineTo(h,l-u).arcTo(h-c,l-c,t+r-u,l,u).lineTo(t+u,l).arcTo(t+c,l-c,t,l-u,u).closePath()}chamferRect(t,e,r,s,n,a){if(n<=0)return this.rect(t,e,r,s);const o=Math.min(n,Math.min(r,s)/2),h=t+r,l=e+s,c=[t+o,e,h-o,e,h,e+o,h,l-o,h-o,l,t+o,l,t,l-o,t,e+o];for(let u=c.length-1;u>=2;u-=2)c[u]===c[u-2]&&c[u-1]===c[u-3]&&c.splice(u-1,2);return this.poly(c,!0,a)}ellipse(t,e,r,s,n){return this.drawShape(new Ie(t,e,r,s),n),this}roundRect(t,e,r,s,n,a){return this.drawShape(new ze(t,e,r,s,n),a),this}drawShape(t,e){return this.endPoly(),this.shapePrimitives.push({shape:t,transform:e}),this}startPoly(t,e){let r=this._currentPoly;return r&&this.endPoly(),r=new It,r.points.push(t,e),this._currentPoly=r,this}endPoly(t=!1){const e=this._currentPoly;return e&&e.points.length>2&&(e.closePath=t,this.shapePrimitives.push({shape:e})),this._currentPoly=null,this}_ensurePoly(t=!0){if(!this._currentPoly&&(this._currentPoly=new It,t)){const e=this.shapePrimitives[this.shapePrimitives.length-1];if(e){let r=e.shape.x,s=e.shape.y;if(!e.transform.isIdentity()){const n=e.transform,a=r;r=n.a*r+n.c*s+n.tx,s=n.b*a+n.d*s+n.ty}this._currentPoly.points.push(r,s)}else this._currentPoly.points.push(0,0)}}buildPath(){const t=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let e=0;e<t.instructions.length;e++){const r=t.instructions[e];this[r.action](...r.data)}this.finish()}get bounds(){const t=this._bounds;t.clear();const e=this.shapePrimitives;for(let r=0;r<e.length;r++){const s=e[r],n=s.shape.getBounds(en);s.transform?t.addRect(n,s.transform):t.addRect(n)}return t}}class wt{constructor(t){this.instructions=[],this.uid=K("graphicsPath"),this._dirty=!0,typeof t=="string"?pi(t,this):this.instructions=(t==null?void 0:t.slice())??[]}get shapePath(){return this._shapePath||(this._shapePath=new rn(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(t,e){return t=t.clone(),this.instructions.push({action:"addPath",data:[t,e]}),this._dirty=!0,this}arc(...t){return this.instructions.push({action:"arc",data:t}),this._dirty=!0,this}arcTo(...t){return this.instructions.push({action:"arcTo",data:t}),this._dirty=!0,this}arcToSvg(...t){return this.instructions.push({action:"arcToSvg",data:t}),this._dirty=!0,this}bezierCurveTo(...t){return this.instructions.push({action:"bezierCurveTo",data:t}),this._dirty=!0,this}bezierCurveToShort(t,e,r,s,n){const a=this.instructions[this.instructions.length-1],o=this.getLastPoint(pt.shared);let h=0,l=0;if(!a||a.action!=="bezierCurveTo")h=o.x,l=o.y;else{h=a.data[2],l=a.data[3];const c=o.x,u=o.y;h=c+(c-h),l=u+(u-l)}return this.instructions.push({action:"bezierCurveTo",data:[h,l,t,e,r,s,n]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...t){return this.instructions.push({action:"ellipse",data:t}),this._dirty=!0,this}lineTo(...t){return this.instructions.push({action:"lineTo",data:t}),this._dirty=!0,this}moveTo(...t){return this.instructions.push({action:"moveTo",data:t}),this}quadraticCurveTo(...t){return this.instructions.push({action:"quadraticCurveTo",data:t}),this._dirty=!0,this}quadraticCurveToShort(t,e,r){const s=this.instructions[this.instructions.length-1],n=this.getLastPoint(pt.shared);let a=0,o=0;if(!s||s.action!=="quadraticCurveTo")a=n.x,o=n.y;else{a=s.data[0],o=s.data[1];const h=n.x,l=n.y;a=h+(h-a),o=l+(l-o)}return this.instructions.push({action:"quadraticCurveTo",data:[a,o,t,e,r]}),this._dirty=!0,this}rect(t,e,r,s,n){return this.instructions.push({action:"rect",data:[t,e,r,s,n]}),this._dirty=!0,this}circle(t,e,r,s){return this.instructions.push({action:"circle",data:[t,e,r,s]}),this._dirty=!0,this}roundRect(...t){return this.instructions.push({action:"roundRect",data:t}),this._dirty=!0,this}poly(...t){return this.instructions.push({action:"poly",data:t}),this._dirty=!0,this}regularPoly(...t){return this.instructions.push({action:"regularPoly",data:t}),this._dirty=!0,this}roundPoly(...t){return this.instructions.push({action:"roundPoly",data:t}),this._dirty=!0,this}roundShape(...t){return this.instructions.push({action:"roundShape",data:t}),this._dirty=!0,this}filletRect(...t){return this.instructions.push({action:"filletRect",data:t}),this._dirty=!0,this}chamferRect(...t){return this.instructions.push({action:"chamferRect",data:t}),this._dirty=!0,this}star(t,e,r,s,n,a,o){n=n||s/2;const h=-1*Math.PI/2+a,l=r*2,c=Math.PI*2/l,u=[];for(let d=0;d<l;d++){const f=d%2?n:s,p=d*c+h;u.push(t+f*Math.cos(p),e+f*Math.sin(p))}return this.poly(u,!0,o),this}clone(t=!1){const e=new wt;if(!t)e.instructions=this.instructions.slice();else for(let r=0;r<this.instructions.length;r++){const s=this.instructions[r];e.instructions.push({action:s.action,data:s.data.slice()})}return e}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(t){if(t.isIdentity())return this;const e=t.a,r=t.b,s=t.c,n=t.d,a=t.tx,o=t.ty;let h=0,l=0,c=0,u=0,d=0,f=0,p=0,m=0;for(let g=0;g<this.instructions.length;g++){const _=this.instructions[g],x=_.data;switch(_.action){case"moveTo":case"lineTo":h=x[0],l=x[1],x[0]=e*h+s*l+a,x[1]=r*h+n*l+o;break;case"bezierCurveTo":c=x[0],u=x[1],d=x[2],f=x[3],h=x[4],l=x[5],x[0]=e*c+s*u+a,x[1]=r*c+n*u+o,x[2]=e*d+s*f+a,x[3]=r*d+n*f+o,x[4]=e*h+s*l+a,x[5]=r*h+n*l+o;break;case"quadraticCurveTo":c=x[0],u=x[1],h=x[2],l=x[3],x[0]=e*c+s*u+a,x[1]=r*c+n*u+o,x[2]=e*h+s*l+a,x[3]=r*h+n*l+o;break;case"arcToSvg":h=x[5],l=x[6],p=x[0],m=x[1],x[0]=e*p+s*m,x[1]=r*p+n*m,x[5]=e*h+s*l+a,x[6]=r*h+n*l+o;break;case"circle":x[4]=Ft(x[3],t);break;case"rect":x[4]=Ft(x[4],t);break;case"ellipse":x[8]=Ft(x[8],t);break;case"roundRect":x[5]=Ft(x[5],t);break;case"addPath":x[0].transform(t);break;case"poly":x[2]=Ft(x[2],t);break;default:at("unknown transform action",_.action);break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(t){let e=this.instructions.length-1,r=this.instructions[e];if(!r)return t.x=0,t.y=0,t;for(;r.action==="closePath";){if(e--,e<0)return t.x=0,t.y=0,t;r=this.instructions[e]}switch(r.action){case"moveTo":case"lineTo":t.x=r.data[0],t.y=r.data[1];break;case"quadraticCurveTo":t.x=r.data[2],t.y=r.data[3];break;case"bezierCurveTo":t.x=r.data[4],t.y=r.data[5];break;case"arc":case"arcToSvg":t.x=r.data[5],t.y=r.data[6];break;case"addPath":r.data[0].getLastPoint(t);break}return t}}function Ft(i,t){return i?i.prepend(t):t.clone()}function sn(i,t){if(typeof i=="string"){const r=document.createElement("div");r.innerHTML=i.trim(),i=r.querySelector("svg")}const e={context:t,path:new wt};return Qr(i,e,null,null),t}function Qr(i,t,e,r){const s=i.children,{fillStyle:n,strokeStyle:a}=nn(i);n&&e?e={...e,...n}:n&&(e=n),a&&r?r={...r,...a}:a&&(r=a),t.context.fillStyle=e,t.context.strokeStyle=r;let o,h,l,c,u,d,f,p,m,g,_,x,y,b,P,k,T;switch(i.nodeName.toLowerCase()){case"path":b=i.getAttribute("d"),P=new wt(b),t.context.path(P),e&&t.context.fill(),r&&t.context.stroke();break;case"circle":f=$(i,"cx",0),p=$(i,"cy",0),m=$(i,"r",0),t.context.ellipse(f,p,m,m),e&&t.context.fill(),r&&t.context.stroke();break;case"rect":o=$(i,"x",0),h=$(i,"y",0),k=$(i,"width",0),T=$(i,"height",0),g=$(i,"rx",0),_=$(i,"ry",0),g||_?t.context.roundRect(o,h,k,T,g||_):t.context.rect(o,h,k,T),e&&t.context.fill(),r&&t.context.stroke();break;case"ellipse":f=$(i,"cx",0),p=$(i,"cy",0),g=$(i,"rx",0),_=$(i,"ry",0),t.context.beginPath(),t.context.ellipse(f,p,g,_),e&&t.context.fill(),r&&t.context.stroke();break;case"line":l=$(i,"x1",0),c=$(i,"y1",0),u=$(i,"x2",0),d=$(i,"y2",0),t.context.beginPath(),t.context.moveTo(l,c),t.context.lineTo(u,d),r&&t.context.stroke();break;case"polygon":y=i.getAttribute("points"),x=y.match(/\d+/g).map(v=>parseInt(v,10)),t.context.poly(x,!0),e&&t.context.fill(),r&&t.context.stroke();break;case"polyline":y=i.getAttribute("points"),x=y.match(/\d+/g).map(v=>parseInt(v,10)),t.context.poly(x,!1),r&&t.context.stroke();break;case"g":case"svg":break;default:{console.info(`[SVG parser] <${i.nodeName}> elements unsupported`);break}}for(let v=0;v<s.length;v++)Qr(s[v],t,e,r)}function $(i,t,e){const r=i.getAttribute(t);return r?Number(r):e}function nn(i){const t=i.getAttribute("style"),e={},r={};let s=!1,n=!1;if(t){const a=t.split(";");for(let o=0;o<a.length;o++){const h=a[o],[l,c]=h.split(":");switch(l){case"stroke":c!=="none"&&(e.color=H.shared.setValue(c).toNumber(),n=!0);break;case"stroke-width":e.width=Number(c);break;case"fill":c!=="none"&&(s=!0,r.color=H.shared.setValue(c).toNumber());break;case"fill-opacity":r.alpha=Number(c);break;case"stroke-opacity":e.alpha=Number(c);break;case"opacity":r.alpha=Number(c),e.alpha=Number(c);break}}}else{const a=i.getAttribute("stroke");a&&a!=="none"&&(n=!0,e.color=H.shared.setValue(a).toNumber(),e.width=$(i,"stroke-width",1));const o=i.getAttribute("fill");o&&o!=="none"&&(s=!0,r.color=H.shared.setValue(o).toNumber())}return{strokeStyle:n?e:null,fillStyle:s?r:null}}const Zr=class Be{constructor(t,e,r,s){this.uid=K("fillGradient"),this.type="linear",this.gradientStops=[],this.x0=t,this.y0=e,this.x1=r,this.y1=s}addColorStop(t,e){return this.gradientStops.push({offset:t,color:H.shared.setValue(e).toHex()}),this}buildLinearGradient(){const t=Be.defaultTextureSize,{gradientStops:e}=this,r=q.get().createCanvas();r.width=t,r.height=t;const s=r.getContext("2d"),n=s.createLinearGradient(0,0,Be.defaultTextureSize,1);for(let m=0;m<e.length;m++){const g=e[m];n.addColorStop(g.offset,g.color)}s.fillStyle=n,s.fillRect(0,0,t,t),this.texture=new O({source:new Rr({resource:r,addressModeU:"clamp-to-edge",addressModeV:"repeat"})});const{x0:a,y0:o,x1:h,y1:l}=this,c=new V,u=h-a,d=l-o,f=Math.sqrt(u*u+d*d),p=Math.atan2(d,u);c.translate(-a,-o),c.scale(1/t,1/t),c.rotate(-p),c.scale(256/f,1),this.transform=c}};Zr.defaultTextureSize=256;let Le=Zr;const lr={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class Jr{constructor(t,e){this.uid=K("fillPattern"),this.transform=new V,this.texture=t,this.transform.scale(1/t.frame.width,1/t.frame.height),e&&(t.source.style.addressModeU=lr[e].addressModeU,t.source.style.addressModeV=lr[e].addressModeV)}setTransform(t){const e=this.texture;this.transform.copyFrom(t),this.transform.invert(),this.transform.scale(1/e.frame.width,1/e.frame.height)}}function st(i,t){var a;if(i==null)return null;let e,r;if(i!=null&&i.fill?(r=i.fill,e={...t,...i}):(r=i,e=t),H.isColorLike(r)){const o=H.shared.setValue(r??0);return{...e,color:o.toNumber(),alpha:o.alpha===1?e.alpha:o.alpha,texture:O.WHITE}}else if(r instanceof Jr){const o=r;return{...e,color:16777215,texture:o.texture,matrix:o.transform,fill:e.fill??null}}else if(r instanceof Le){const o=r;return o.buildLinearGradient(),{...e,color:16777215,texture:o.texture,matrix:o.transform}}const s={...t,...i};if(s.texture){if(s.texture!==O.WHITE){const h=((a=s.matrix)==null?void 0:a.invert())||new V;h.scale(1/s.texture.frame.width,1/s.texture.frame.height),s.matrix=h}const o=s.texture.source.style;o.addressMode==="clamp-to-edge"&&(o.addressMode="repeat")}const n=H.shared.setValue(s.color);return s.alpha*=n.alpha,s.color=n.toNumber(),s.matrix=s.matrix?s.matrix.clone():null,s}const an=new pt,ur=new V,He=class J extends vt{constructor(){super(...arguments),this.uid=K("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new wt,this._transform=new V,this._fillStyle={...J.defaultFillStyle},this._strokeStyle={...J.defaultStrokeStyle},this._stateStack=[],this._tick=0,this._bounds=new Gt,this._boundsDirty=!0}clone(){const t=new J;return t.batchMode=this.batchMode,t.instructions=this.instructions.slice(),t._activePath=this._activePath.clone(),t._transform=this._transform.clone(),t._fillStyle={...this._fillStyle},t._strokeStyle={...this._strokeStyle},t._stateStack=this._stateStack.slice(),t._bounds=this._bounds.clone(),t._boundsDirty=!0,t}get fillStyle(){return this._fillStyle}set fillStyle(t){this._fillStyle=st(t,J.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(t){this._strokeStyle=st(t,J.defaultStrokeStyle)}setFillStyle(t){return this._fillStyle=st(t,J.defaultFillStyle),this}setStrokeStyle(t){return this._strokeStyle=st(t,J.defaultStrokeStyle),this}texture(t,e,r,s,n,a){return this.instructions.push({action:"texture",data:{image:t,dx:r||0,dy:s||0,dw:n||t.frame.width,dh:a||t.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:e?H.shared.setValue(e).toNumber():16777215}}),this.onUpdate(),this}beginPath(){return this._activePath=new wt,this}fill(t,e){let r;const s=this.instructions[this.instructions.length-1];return this._tick===0&&s&&s.action==="stroke"?r=s.data.path:r=this._activePath.clone(),r?(t!=null&&(e!==void 0&&typeof t=="number"&&(E(D,"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),t={color:t,alpha:e}),this._fillStyle=st(t,J.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:r}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:t,y:e}=this._activePath.getLastPoint(pt.shared);this._activePath.clear(),this._activePath.moveTo(t,e)}stroke(t){let e;const r=this.instructions[this.instructions.length-1];return this._tick===0&&r&&r.action==="fill"?e=r.data.path:e=this._activePath.clone(),e?(t!=null&&(this._strokeStyle=st(t,J.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:e}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let t=0;t<2;t++){const e=this.instructions[this.instructions.length-1-t],r=this._activePath.clone();if(e&&(e.action==="stroke"||e.action==="fill"))if(e.data.hole)e.data.hole.addPath(r);else{e.data.hole=r;break}}return this._initNextPathLocation(),this}arc(t,e,r,s,n,a){this._tick++;const o=this._transform;return this._activePath.arc(o.a*t+o.c*e+o.tx,o.b*t+o.d*e+o.ty,r,s,n,a),this}arcTo(t,e,r,s,n){this._tick++;const a=this._transform;return this._activePath.arcTo(a.a*t+a.c*e+a.tx,a.b*t+a.d*e+a.ty,a.a*r+a.c*s+a.tx,a.b*r+a.d*s+a.ty,n),this}arcToSvg(t,e,r,s,n,a,o){this._tick++;const h=this._transform;return this._activePath.arcToSvg(t,e,r,s,n,h.a*a+h.c*o+h.tx,h.b*a+h.d*o+h.ty),this}bezierCurveTo(t,e,r,s,n,a,o){this._tick++;const h=this._transform;return this._activePath.bezierCurveTo(h.a*t+h.c*e+h.tx,h.b*t+h.d*e+h.ty,h.a*r+h.c*s+h.tx,h.b*r+h.d*s+h.ty,h.a*n+h.c*a+h.tx,h.b*n+h.d*a+h.ty,o),this}closePath(){var t;return this._tick++,(t=this._activePath)==null||t.closePath(),this}ellipse(t,e,r,s){return this._tick++,this._activePath.ellipse(t,e,r,s,this._transform.clone()),this}circle(t,e,r){return this._tick++,this._activePath.circle(t,e,r,this._transform.clone()),this}path(t){return this._tick++,this._activePath.addPath(t,this._transform.clone()),this}lineTo(t,e){this._tick++;const r=this._transform;return this._activePath.lineTo(r.a*t+r.c*e+r.tx,r.b*t+r.d*e+r.ty),this}moveTo(t,e){this._tick++;const r=this._transform,s=this._activePath.instructions,n=r.a*t+r.c*e+r.tx,a=r.b*t+r.d*e+r.ty;return s.length===1&&s[0].action==="moveTo"?(s[0].data[0]=n,s[0].data[1]=a,this):(this._activePath.moveTo(n,a),this)}quadraticCurveTo(t,e,r,s,n){this._tick++;const a=this._transform;return this._activePath.quadraticCurveTo(a.a*t+a.c*e+a.tx,a.b*t+a.d*e+a.ty,a.a*r+a.c*s+a.tx,a.b*r+a.d*s+a.ty,n),this}rect(t,e,r,s){return this._tick++,this._activePath.rect(t,e,r,s,this._transform.clone()),this}roundRect(t,e,r,s,n){return this._tick++,this._activePath.roundRect(t,e,r,s,n,this._transform.clone()),this}poly(t,e){return this._tick++,this._activePath.poly(t,e,this._transform.clone()),this}regularPoly(t,e,r,s,n=0,a){return this._tick++,this._activePath.regularPoly(t,e,r,s,n,a),this}roundPoly(t,e,r,s,n,a){return this._tick++,this._activePath.roundPoly(t,e,r,s,n,a),this}roundShape(t,e,r,s){return this._tick++,this._activePath.roundShape(t,e,r,s),this}filletRect(t,e,r,s,n){return this._tick++,this._activePath.filletRect(t,e,r,s,n),this}chamferRect(t,e,r,s,n,a){return this._tick++,this._activePath.chamferRect(t,e,r,s,n,a),this}star(t,e,r,s,n=0,a=0){return this._tick++,this._activePath.star(t,e,r,s,n,a,this._transform.clone()),this}svg(t){return this._tick++,sn(t,this),this}restore(){const t=this._stateStack.pop();return t&&(this._transform=t.transform,this._fillStyle=t.fillStyle,this._strokeStyle=t.strokeStyle),this}save(){return this._stateStack.push({transform:this._transform.clone(),fillStyle:{...this._fillStyle},strokeStyle:{...this._strokeStyle}}),this}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(t){return this._transform.rotate(t),this}scale(t,e=t){return this._transform.scale(t,e),this}setTransform(t,e,r,s,n,a){return t instanceof V?(this._transform.set(t.a,t.b,t.c,t.d,t.tx,t.ty),this):(this._transform.set(t,e,r,s,n,a),this)}transform(t,e,r,s,n,a){return t instanceof V?(this._transform.append(t),this):(ur.set(t,e,r,s,n,a),this._transform.append(ur),this)}translate(t,e=t){return this._transform.translate(t,e),this}clear(){return this._activePath.clear(),this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this.dirty||(this.emit("update",this,16),this.dirty=!0,this._boundsDirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;const t=this._bounds;t.clear();for(let e=0;e<this.instructions.length;e++){const r=this.instructions[e],s=r.action;if(s==="fill"){const n=r.data;t.addBounds(n.path.bounds)}else if(s==="texture"){const n=r.data;t.addFrame(n.dx,n.dy,n.dx+n.dw,n.dy+n.dh,n.transform)}if(s==="stroke"){const n=r.data,a=n.style.width/2,o=n.path.bounds;t.addFrame(o.minX-a,o.minY-a,o.maxX+a,o.maxY+a)}}return t}containsPoint(t){var s;if(!this.bounds.containsPoint(t.x,t.y))return!1;const e=this.instructions;let r=!1;for(let n=0;n<e.length;n++){const a=e[n],o=a.data,h=o.path;if(!a.action||!h)continue;const l=o.style,c=h.shapePath.shapePrimitives;for(let u=0;u<c.length;u++){const d=c[u].shape;if(!l||!d)continue;const f=c[u].transform,p=f?f.applyInverse(t,an):t;a.action==="fill"?r=d.contains(p.x,p.y):r=d.strokeContains(p.x,p.y,l.width);const m=o.hole;if(m){const g=(s=m.shapePath)==null?void 0:s.shapePrimitives;if(g)for(let _=0;_<g.length;_++)g[_].shape.contains(p.x,p.y)&&(r=!1)}if(r)return!0}}return r}destroy(t=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),typeof t=="boolean"?t:t==null?void 0:t.texture){const r=typeof t=="boolean"?t:t==null?void 0:t.textureSource;this._fillStyle.texture&&this._fillStyle.texture.destroy(r),this._strokeStyle.texture&&this._strokeStyle.texture.destroy(r)}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};He.defaultFillStyle={color:16777215,alpha:1,texture:O.WHITE,matrix:null,fill:null};He.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:O.WHITE,matrix:null,fill:null};let dt=He,on=0;class hn{constructor(t){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=t||{},this.enableFullScreen=!1}createTexture(t,e,r){const s=new Hs({...this.textureOptions,width:t,height:e,resolution:1,antialias:r,autoGarbageCollect:!0});return new O({source:s,label:`texturePool_${on++}`})}getOptimalTexture(t,e,r=1,s){let n=Math.ceil(t*r-1e-6),a=Math.ceil(e*r-1e-6);n=yt(n),a=yt(a);const o=(n<<17)+(a<<1)+(s?1:0);this._texturePool[o]||(this._texturePool[o]=[]);let h=this._texturePool[o].pop();return h||(h=this.createTexture(n,a,s)),h.source._resolution=r,h.source.width=n/r,h.source.height=a/r,h.source.pixelWidth=n,h.source.pixelHeight=a,h.frame.x=0,h.frame.y=0,h.frame.width=t,h.frame.height=e,h.updateUvs(),this._poolKeyHash[h.uid]=o,h}getSameSizeTexture(t,e=!1){const r=t.source;return this.getOptimalTexture(t.width,t.height,r._resolution,e)}returnTexture(t){const e=this._poolKeyHash[t.uid];this._texturePool[e].push(t)}clear(t){if(t=t!==!1,t)for(const e in this._texturePool){const r=this._texturePool[e];if(r)for(let s=0;s<r.length;s++)r[s].destroy(!0)}this._texturePool={}}}const tt=new hn;class ts{constructor(t){this._renderer=t}push(t,e,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:e,filterEffect:t})}pop(t,e,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(t){t.action==="pushFilter"?this._renderer.filter.push(t):t.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}ts.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"filter"};const cn=new V;function ln(i,t){return t.clear(),es(i,t),t.isValid||t.set(0,0,0,0),i.renderGroup?t.applyMatrix(i.renderGroup.localTransform):t.applyMatrix(i.parentRenderGroup.worldTransform),t}function es(i,t){if(i.localDisplayStatus!==7||!i.measurable)return;const e=!!i.effects.length;let r=t;if((i.renderGroup||e)&&(r=Zt.get().clear()),i.boundsArea)t.addRect(i.boundsArea,i.worldTransform);else{if(i.renderPipeId){const n=i.bounds;r.addFrame(n.minX,n.minY,n.maxX,n.maxY,i.groupTransform)}const s=i.children;for(let n=0;n<s.length;n++)es(s[n],r)}if(e){let s=!1;for(let n=0;n<i.effects.length;n++)i.effects[n].addBounds&&(s||(s=!0,r.applyMatrix(i.parentRenderGroup.worldTransform)),i.effects[n].addBounds(r,!0));s&&(r.applyMatrix(i.parentRenderGroup.worldTransform.copyTo(cn).invert()),t.addBounds(r,i.relativeGroupTransform)),t.addBounds(r),Zt.return(r)}else i.renderGroup&&(t.addBounds(r,i.relativeGroupTransform),Zt.return(r))}function un(i,t){t.clear();const e=t.matrix;for(let r=0;r<i.length;r++){const s=i[r];s.globalDisplayStatus<7||(t.matrix=s.worldTransform,s.addBounds(t))}return t.matrix=e,t}const dn=new Ge({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),location:0,format:"float32x2",stride:2*4,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class rs{constructor(t){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new gt({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new _t({}),this.renderer=t}get activeBackTexture(){var t;return(t=this._activeFilterData)==null?void 0:t.backTexture}push(t){var f;const e=this.renderer,r=t.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const s=this._filterStack[this._filterStackIndex];if(this._filterStackIndex++,r.length===0){s.skip=!0;return}const n=s.bounds;t.renderables?un(t.renderables,n):t.filterEffect.filterArea?(n.clear(),n.addRect(t.filterEffect.filterArea),n.applyMatrix(t.container.worldTransform)):ln(t.container,n);const a=e.renderTarget.rootRenderTarget.colorTexture.source;let o=a._resolution,h=0,l=a.antialias,c=!1,u=!1;for(let p=0;p<r.length;p++){const m=r[p];if(o=Math.min(o,m.resolution),h+=m.padding,m.antialias!=="inherit"&&(m.antialias==="on"?l=!0:l=!1),!!!(m.compatibleRenderers&e.type)){u=!1;break}if(m.blendRequired&&!(((f=e.backBuffer)==null?void 0:f.useBackBuffer)??!0)){at("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),u=!1;break}u=m.enabled||u,c=c||m.blendRequired}if(!u){s.skip=!0;return}const d=e.renderTarget.rootViewPort;if(n.scale(o).fitBounds(0,d.width,0,d.height).scale(1/o).pad(h).ceil(),!n.isPositive){s.skip=!0;return}s.skip=!1,s.bounds=n,s.blendRequired=c,s.container=t.container,s.filterEffect=t.filterEffect,s.previousRenderSurface=e.renderTarget.renderSurface,s.inputTexture=tt.getOptimalTexture(n.width,n.height,o,l),e.renderTarget.bind(s.inputTexture,!0),e.globalUniforms.push({offset:n})}pop(){const t=this.renderer;this._filterStackIndex--;const e=this._filterStack[this._filterStackIndex];if(e.skip)return;this._activeFilterData=e;const r=e.inputTexture,s=e.bounds;let n=O.EMPTY;if(t.renderTarget.finishRenderPass(),e.blendRequired){const o=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null,h=t.renderTarget.getRenderTarget(e.previousRenderSurface);n=this.getBackTexture(h,s,o)}e.backTexture=n;const a=e.filterEffect.filters;if(this._globalFilterBindGroup.setResource(r.source.style,2),this._globalFilterBindGroup.setResource(n.source,3),t.globalUniforms.pop(),a.length===1)a[0].apply(this,r,e.previousRenderSurface,!1),tt.returnTexture(r);else{let o=e.inputTexture,h=tt.getOptimalTexture(s.width,s.height,o.source._resolution,!1),l=0;for(l=0;l<a.length-1;++l){a[l].apply(this,o,h,!0);const u=o;o=h,h=u}a[l].apply(this,o,e.previousRenderSurface,!1),tt.returnTexture(o),tt.returnTexture(h)}e.blendRequired&&tt.returnTexture(n)}getBackTexture(t,e,r){const s=t.colorTexture.source._resolution,n=tt.getOptimalTexture(e.width,e.height,s,!1);let a=e.minX,o=e.minY;r&&(a-=r.minX,o-=r.minY),a=Math.floor(a*s),o=Math.floor(o*s);const h=Math.ceil(e.width*s),l=Math.ceil(e.height*s);return this.renderer.renderTarget.copyToTexture(t,n,{x:a,y:o},{width:h,height:l},{x:0,y:0}),n}applyFilter(t,e,r,s){const n=this.renderer,a=this._filterStack[this._filterStackIndex],o=a.bounds,h=pt.shared,c=a.previousRenderSurface===r;let u=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,d=this._filterStackIndex-1;for(;d>0&&this._filterStack[d].skip;)--d;d>0&&(u=this._filterStack[d].inputTexture.source._resolution);const f=this._filterGlobalUniforms,p=f.uniforms,m=p.uOutputFrame,g=p.uInputSize,_=p.uInputPixel,x=p.uInputClamp,y=p.uGlobalFrame,b=p.uOutputTexture;if(c){let T=this._filterStackIndex;for(;T>0;){T--;const v=this._filterStack[this._filterStackIndex-1];if(!v.skip){h.x=v.bounds.minX,h.y=v.bounds.minY;break}}m[0]=o.minX-h.x,m[1]=o.minY-h.y}else m[0]=0,m[1]=0;m[2]=e.frame.width,m[3]=e.frame.height,g[0]=e.source.width,g[1]=e.source.height,g[2]=1/g[0],g[3]=1/g[1],_[0]=e.source.pixelWidth,_[1]=e.source.pixelHeight,_[2]=1/_[0],_[3]=1/_[1],x[0]=.5*_[2],x[1]=.5*_[3],x[2]=e.frame.width*g[2]-.5*_[2],x[3]=e.frame.height*g[3]-.5*_[3];const P=this.renderer.renderTarget.rootRenderTarget.colorTexture;y[0]=h.x*u,y[1]=h.y*u,y[2]=P.source.width*u,y[3]=P.source.height*u;const k=this.renderer.renderTarget.getRenderTarget(r);if(n.renderTarget.bind(r,!!s),r instanceof O?(b[0]=r.frame.width,b[1]=r.frame.height):(b[0]=k.width,b[1]=k.height),b[2]=k.isRoot?-1:1,f.update(),n.renderPipes.uniformBatch){const T=n.renderPipes.uniformBatch.getUboResource(f);this._globalFilterBindGroup.setResource(T,0)}else this._globalFilterBindGroup.setResource(f,0);this._globalFilterBindGroup.setResource(e.source,1),this._globalFilterBindGroup.setResource(e.source.style,2),t.groups[0]=this._globalFilterBindGroup,n.encoder.draw({geometry:dn,shader:t,state:t._state,topology:"triangle-list"}),n.type===bt.WEBGL&&n.renderTarget.finishRenderPass()}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Gt,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(t,e){const r=this._activeFilterData,s=t.set(r.inputTexture._source.width,0,0,r.inputTexture._source.height,r.bounds.minX,r.bounds.minY),n=e.worldTransform.copyTo(V.shared);return n.invert(),s.prepend(n),s.scale(1/e.texture.frame.width,1/e.texture.frame.height),s.translate(e.anchor.x,e.anchor.y),s}}rs.extension={type:[R.WebGLSystem,R.WebGPUSystem],name:"filter"};class jt extends Os{constructor(t){t instanceof dt&&(t={context:t});const{context:e,roundPixels:r,...s}=t||{};super({label:"Graphics",...s}),this.canBundle=!0,this.renderPipeId="graphics",this._roundPixels=0,e?this._context=e:this._context=this._ownedContext=new dt,this._context.on("update",this.onViewUpdate,this),this.allowChildren=!1,this.roundPixels=r??!1}set context(t){t!==this._context&&(this._context.off("update",this.onViewUpdate,this),this._context=t,this._context.on("update",this.onViewUpdate,this),this.onViewUpdate())}get context(){return this._context}get bounds(){return this._context.bounds}addBounds(t){t.addBounds(this._context.bounds)}containsPoint(t){return this._context.containsPoint(t)}get roundPixels(){return!!this._roundPixels}set roundPixels(t){this._roundPixels=t?1:0}onViewUpdate(){if(this._didChangeId+=4096,this._didGraphicsUpdate=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const t=this.renderGroup||this.parentRenderGroup;t&&t.onChildViewUpdate(this)}destroy(t){this._ownedContext&&!t?this._ownedContext.destroy(t):(t===!0||(t==null?void 0:t.context)===!0)&&this._context.destroy(t),this._ownedContext=null,this._context=null,super.destroy(t)}_callContextMethod(t,e){return this.context[t](...e),this}setFillStyle(...t){return this._callContextMethod("setFillStyle",t)}setStrokeStyle(...t){return this._callContextMethod("setStrokeStyle",t)}fill(...t){return this._callContextMethod("fill",t)}stroke(...t){return this._callContextMethod("stroke",t)}texture(...t){return this._callContextMethod("texture",t)}beginPath(){return this._callContextMethod("beginPath",[])}cut(){return this._callContextMethod("cut",[])}arc(...t){return this._callContextMethod("arc",t)}arcTo(...t){return this._callContextMethod("arcTo",t)}arcToSvg(...t){return this._callContextMethod("arcToSvg",t)}bezierCurveTo(...t){return this._callContextMethod("bezierCurveTo",t)}closePath(){return this._callContextMethod("closePath",[])}ellipse(...t){return this._callContextMethod("ellipse",t)}circle(...t){return this._callContextMethod("circle",t)}path(...t){return this._callContextMethod("path",t)}lineTo(...t){return this._callContextMethod("lineTo",t)}moveTo(...t){return this._callContextMethod("moveTo",t)}quadraticCurveTo(...t){return this._callContextMethod("quadraticCurveTo",t)}rect(...t){return this._callContextMethod("rect",t)}roundRect(...t){return this._callContextMethod("roundRect",t)}poly(...t){return this._callContextMethod("poly",t)}regularPoly(...t){return this._callContextMethod("regularPoly",t)}roundPoly(...t){return this._callContextMethod("roundPoly",t)}roundShape(...t){return this._callContextMethod("roundShape",t)}filletRect(...t){return this._callContextMethod("filletRect",t)}chamferRect(...t){return this._callContextMethod("chamferRect",t)}star(...t){return this._callContextMethod("star",t)}svg(...t){return this._callContextMethod("svg",t)}restore(...t){return this._callContextMethod("restore",t)}save(){return this._callContextMethod("save",[])}getTransform(){return this.context.getTransform()}resetTransform(){return this._callContextMethod("resetTransform",[])}rotateTransform(...t){return this._callContextMethod("rotate",t)}scaleTransform(...t){return this._callContextMethod("scale",t)}setTransform(...t){return this._callContextMethod("setTransform",t)}transform(...t){return this._callContextMethod("transform",t)}translateTransform(...t){return this._callContextMethod("translate",t)}clear(){return this._callContextMethod("clear",[])}get fillStyle(){return this._context.fillStyle}set fillStyle(t){this._context.fillStyle=t}get strokeStyle(){return this._context.strokeStyle}set strokeStyle(t){this._context.strokeStyle=t}clone(t=!1){return t?new jt(this._context.clone()):(this._ownedContext=null,new jt(this._context))}lineStyle(t,e,r){E(D,"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");const s={};return t&&(s.width=t),e&&(s.color=e),r&&(s.alpha=r),this.context.strokeStyle=s,this}beginFill(t,e){E(D,"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");const r={};return t&&(r.color=t),e&&(r.alpha=e),this.context.fillStyle=r,this}endFill(){E(D,"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill();const t=this.context.strokeStyle;return(t.width!==dt.defaultStrokeStyle.width||t.color!==dt.defaultStrokeStyle.color||t.alpha!==dt.defaultStrokeStyle.alpha)&&this.context.stroke(),this}drawCircle(...t){return E(D,"Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",t)}drawEllipse(...t){return E(D,"Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",t)}drawPolygon(...t){return E(D,"Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",t)}drawRect(...t){return E(D,"Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",t)}drawRoundedRect(...t){return E(D,"Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",t)}drawStar(...t){return E(D,"Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",t)}}const ss=class is extends Ge{constructor(...t){let e=t[0]??{};e instanceof Float32Array&&(E(D,"use new MeshGeometry({ positions, uvs, indices }) instead"),e={positions:e,uvs:t[1],indices:t[2]}),e={...is.defaultOptions,...e};const r=e.positions||new Float32Array([0,0,1,0,1,1,0,1]),s=e.uvs||new Float32Array([0,0,1,0,1,1,0,1]),n=e.indices||new Uint32Array([0,1,2,0,2,3]),a=e.shrinkBuffersToFit,o=new nt({data:r,label:"attribute-mesh-positions",shrinkToFit:a,usage:L.VERTEX|L.COPY_DST}),h=new nt({data:s,label:"attribute-mesh-uvs",shrinkToFit:a,usage:L.VERTEX|L.COPY_DST}),l=new nt({data:n,label:"index-mesh-buffer",shrinkToFit:a,usage:L.INDEX|L.COPY_DST});super({attributes:{aPosition:{buffer:o,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:h,format:"float32x2",stride:2*4,offset:0}},indexBuffer:l,topology:e.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(t){this.attributes.aPosition.buffer.data=t}get uvs(){return this.attributes.aUV.buffer.data}set uvs(t){this.attributes.aUV.buffer.data=t}get indices(){return this.indexBuffer.data}set indices(t){this.indexBuffer.data=t}};ss.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let Oe=ss;const fn=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function Yt(i){const t=typeof i.fontSize=="number"?`${i.fontSize}px`:i.fontSize;let e=i.fontFamily;Array.isArray(i.fontFamily)||(e=i.fontFamily.split(","));for(let r=e.length-1;r>=0;r--){let s=e[r].trim();!/([\"\'])[^\'\"]+\1/.test(s)&&!fn.includes(s)&&(s=`"${s}"`),e[r]=s}return`${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${t} ${e.join(",")}`}const me={willReadFrequently:!0},Z=class M{static get experimentalLetterSpacingSupported(){let t=M._experimentalLetterSpacingSupported;if(t!==void 0){const e=q.get().getCanvasRenderingContext2D().prototype;t=M._experimentalLetterSpacingSupported="letterSpacing"in e||"textLetterSpacing"in e}return t}constructor(t,e,r,s,n,a,o,h,l){this.text=t,this.style=e,this.width=r,this.height=s,this.lines=n,this.lineWidths=a,this.lineHeight=o,this.maxLineWidth=h,this.fontProperties=l}static measureText(t=" ",e,r=M._canvas,s=e.wordWrap){var x;const n=`${t}:${e.styleKey}`;if(M._measurementCache[n])return M._measurementCache[n];const a=Yt(e),o=M.measureFont(a);o.fontSize===0&&(o.fontSize=e.fontSize,o.ascent=e.fontSize);const h=M.__context;h.font=a;const c=(s?M._wordWrap(t,e,r):t).split(/(?:\r\n|\r|\n)/),u=new Array(c.length);let d=0;for(let y=0;y<c.length;y++){const b=M._measureText(c[y],e.letterSpacing,h);u[y]=b,d=Math.max(d,b)}const f=((x=e._stroke)==null?void 0:x.width)||0;let p=d+f;e.dropShadow&&(p+=e.dropShadow.distance);const m=e.lineHeight||o.fontSize+f;let g=Math.max(m,o.fontSize+f*2)+(c.length-1)*(m+e.leading);return e.dropShadow&&(g+=e.dropShadow.distance),new M(t,e,p,g,c,u,m+e.leading,d,o)}static _measureText(t,e,r){let s=!1;M.experimentalLetterSpacingSupported&&(M.experimentalLetterSpacing?(r.letterSpacing=`${e}px`,r.textLetterSpacing=`${e}px`,s=!0):(r.letterSpacing="0px",r.textLetterSpacing="0px"));let n=r.measureText(t).width;return n>0&&(s?n-=e:n+=(M.graphemeSegmenter(t).length-1)*e),n}static _wordWrap(t,e,r=M._canvas){const s=r.getContext("2d",me);let n=0,a="",o="";const h=Object.create(null),{letterSpacing:l,whiteSpace:c}=e,u=M._collapseSpaces(c),d=M._collapseNewlines(c);let f=!u;const p=e.wordWrapWidth+l,m=M._tokenize(t);for(let g=0;g<m.length;g++){let _=m[g];if(M._isNewline(_)){if(!d){o+=M._addLine(a),f=!u,a="",n=0;continue}_=" "}if(u){const y=M.isBreakingSpace(_),b=M.isBreakingSpace(a[a.length-1]);if(y&&b)continue}const x=M._getFromCache(_,l,h,s);if(x>p)if(a!==""&&(o+=M._addLine(a),a="",n=0),M.canBreakWords(_,e.breakWords)){const y=M.wordWrapSplit(_);for(let b=0;b<y.length;b++){let P=y[b],k=P,T=1;for(;y[b+T];){const S=y[b+T];if(!M.canBreakChars(k,S,_,b,e.breakWords))P+=S;else break;k=S,T++}b+=T-1;const v=M._getFromCache(P,l,h,s);v+n>p&&(o+=M._addLine(a),f=!1,a="",n=0),a+=P,n+=v}}else{a.length>0&&(o+=M._addLine(a),a="",n=0);const y=g===m.length-1;o+=M._addLine(_,!y),f=!1,a="",n=0}else x+n>p&&(f=!1,o+=M._addLine(a),a="",n=0),(a.length>0||!M.isBreakingSpace(_)||f)&&(a+=_,n+=x)}return o+=M._addLine(a,!1),o}static _addLine(t,e=!0){return t=M._trimRight(t),t=e?`${t}
`:t,t}static _getFromCache(t,e,r,s){let n=r[t];return typeof n!="number"&&(n=M._measureText(t,e,s)+e,r[t]=n),n}static _collapseSpaces(t){return t==="normal"||t==="pre-line"}static _collapseNewlines(t){return t==="normal"}static _trimRight(t){if(typeof t!="string")return"";for(let e=t.length-1;e>=0;e--){const r=t[e];if(!M.isBreakingSpace(r))break;t=t.slice(0,-1)}return t}static _isNewline(t){return typeof t!="string"?!1:M._newlines.includes(t.charCodeAt(0))}static isBreakingSpace(t,e){return typeof t!="string"?!1:M._breakingSpaces.includes(t.charCodeAt(0))}static _tokenize(t){const e=[];let r="";if(typeof t!="string")return e;for(let s=0;s<t.length;s++){const n=t[s],a=t[s+1];if(M.isBreakingSpace(n,a)||M._isNewline(n)){r!==""&&(e.push(r),r=""),e.push(n);continue}r+=n}return r!==""&&e.push(r),e}static canBreakWords(t,e){return e}static canBreakChars(t,e,r,s,n){return!0}static wordWrapSplit(t){return M.graphemeSegmenter(t)}static measureFont(t){if(M._fonts[t])return M._fonts[t];const e=M._context;e.font=t;const r=e.measureText(M.METRICS_STRING+M.BASELINE_SYMBOL),s={ascent:r.actualBoundingBoxAscent,descent:r.actualBoundingBoxDescent,fontSize:r.actualBoundingBoxAscent+r.actualBoundingBoxDescent};return M._fonts[t]=s,s}static clearMetrics(t=""){t?delete M._fonts[t]:M._fonts={}}static get _canvas(){if(!M.__canvas){let t;try{const e=new OffscreenCanvas(0,0),r=e.getContext("2d",me);if(r!=null&&r.measureText)return M.__canvas=e,e;t=q.get().createCanvas()}catch{t=q.get().createCanvas()}t.width=t.height=10,M.__canvas=t}return M.__canvas}static get _context(){return M.__context||(M.__context=M._canvas.getContext("2d",me)),M.__context}};Z.METRICS_STRING="|ÉqÅ";Z.BASELINE_SYMBOL="M";Z.BASELINE_MULTIPLIER=1.4;Z.HEIGHT_MULTIPLIER=2;Z.graphemeSegmenter=(()=>{if(typeof(Intl==null?void 0:Intl.Segmenter)=="function"){const i=new Intl.Segmenter;return t=>[...i.segment(t)].map(e=>e.segment)}return i=>[...i]})();Z.experimentalLetterSpacing=!1;Z._fonts={};Z._newlines=[10,13];Z._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288];Z._measurementCache={};let et=Z;const dr=["_fontFamily","_fontStyle","_fontSize","_fontVariant","_fontWeight","_breakWords","_align","_leading","_letterSpacing","_lineHeight","_textBaseline","_whiteSpace","_wordWrap","_wordWrapWidth","_padding","_cssOverrides","_trim"];function ns(i){const t=[];let e=0;for(let r=0;r<dr.length;r++){const s=dr[r];t[e++]=i[s]}return e=as(i._fill,t,e),e=pn(i._stroke,t,e),t.join("-")}function as(i,t,e){var r;return i&&(t[e++]=i.color,t[e++]=i.alpha,t[e++]=(r=i.fill)==null?void 0:r.uid),e}function pn(i,t,e){return i&&(e=as(i,t,e),t[e++]=i.width,t[e++]=i.alignment,t[e++]=i.cap,t[e++]=i.join,t[e++]=i.miterLimit),e}const $e=class xt extends vt{constructor(t={}){super(),gn(t);const e={...xt.defaultTextStyle,...t};for(const r in e){const s=r;this[s]=e[r]}this.update()}get align(){return this._align}set align(t){this._align=t,this.update()}get breakWords(){return this._breakWords}set breakWords(t){this._breakWords=t,this.update()}get dropShadow(){return this._dropShadow}set dropShadow(t){t!==null&&typeof t=="object"?this._dropShadow={...xt.defaultDropShadow,...t}:this._dropShadow=t?{...xt.defaultDropShadow}:null,this.update()}get fontFamily(){return this._fontFamily}set fontFamily(t){this._fontFamily=t,this.update()}get fontSize(){return this._fontSize}set fontSize(t){typeof t=="string"?this._fontSize=parseInt(t,10):this._fontSize=t,this.update()}get fontStyle(){return this._fontStyle}set fontStyle(t){this._fontStyle=t,this.update()}get fontVariant(){return this._fontVariant}set fontVariant(t){this._fontVariant=t,this.update()}get fontWeight(){return this._fontWeight}set fontWeight(t){this._fontWeight=t,this.update()}get leading(){return this._leading}set leading(t){this._leading=t,this.update()}get letterSpacing(){return this._letterSpacing}set letterSpacing(t){this._letterSpacing=t,this.update()}get lineHeight(){return this._lineHeight}set lineHeight(t){this._lineHeight=t,this.update()}get padding(){return this._padding}set padding(t){this._padding=t,this.update()}get trim(){return this._trim}set trim(t){this._trim=t,this.update()}get textBaseline(){return this._textBaseline}set textBaseline(t){this._textBaseline=t,this.update()}get whiteSpace(){return this._whiteSpace}set whiteSpace(t){this._whiteSpace=t,this.update()}get wordWrap(){return this._wordWrap}set wordWrap(t){this._wordWrap=t,this.update()}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(t){this._wordWrapWidth=t,this.update()}get fill(){return this._originalFill}set fill(t){t!==this._originalFill&&(this._originalFill=t,this._fill=st(t===0?"black":t,dt.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(t){t!==this._originalStroke&&(this._originalStroke=t,this._stroke=st(t,dt.defaultStrokeStyle),this.update())}_generateKey(){return this._styleKey=ns(this),this._styleKey}update(){this._styleKey=null,this.emit("update",this)}reset(){const t=xt.defaultTextStyle;for(const e in t)this[e]=t[e]}get styleKey(){return this._styleKey||this._generateKey()}clone(){return new xt({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth})}destroy(t=!1){var r,s,n,a;if(this.removeAllListeners(),typeof t=="boolean"?t:t==null?void 0:t.texture){const o=typeof t=="boolean"?t:t==null?void 0:t.textureSource;(r=this._fill)!=null&&r.texture&&this._fill.texture.destroy(o),(s=this._originalFill)!=null&&s.texture&&this._originalFill.texture.destroy(o),(n=this._stroke)!=null&&n.texture&&this._stroke.texture.destroy(o),(a=this._originalStroke)!=null&&a.texture&&this._originalStroke.texture.destroy(o)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}};$e.defaultDropShadow={alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5};$e.defaultTextStyle={align:"left",breakWords:!1,dropShadow:null,fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};let Tt=$e;function gn(i){const t=i;if(typeof t.dropShadow=="boolean"&&t.dropShadow){const e=Tt.defaultDropShadow;i.dropShadow={alpha:t.dropShadowAlpha??e.alpha,angle:t.dropShadowAngle??e.angle,blur:t.dropShadowBlur??e.blur,color:t.dropShadowColor??e.color,distance:t.dropShadowDistance??e.distance}}if(t.strokeThickness!==void 0){E(D,"strokeThickness is now a part of stroke");const e=t.stroke;i.stroke={color:e,width:t.strokeThickness}}if(Array.isArray(t.fill)){E(D,"gradient fill is now a fill pattern: `new FillGradient(...)`");const e=new Le(0,0,0,i.fontSize*1.7),r=t.fill.map(s=>H.shared.setValue(s).toNumber());r.forEach((s,n)=>{const a=t.fillGradientStops[n]??n/r.length;e.addColorStop(a,s)}),i.fill={fill:e}}}class mn{constructor(t){this._canvasPool=Object.create(null),this.canvasOptions=t||{},this.enableFullScreen=!1}_createCanvasAndContext(t,e){const r=q.get().createCanvas();r.width=t,r.height=e;const s=r.getContext("2d");return{canvas:r,context:s}}getOptimalCanvasAndContext(t,e,r=1){t=Math.ceil(t*r-1e-6),e=Math.ceil(e*r-1e-6),t=yt(t),e=yt(e);const s=(t<<17)+(e<<1);this._canvasPool[s]||(this._canvasPool[s]=[]);let n=this._canvasPool[s].pop();return n||(n=this._createCanvasAndContext(t,e)),n}returnCanvasAndContext(t){const{width:e,height:r}=t.canvas,s=(e<<17)+(r<<1);this._canvasPool[s].push(t)}clear(){this._canvasPool={}}}const ft=new mn;function Xt(i,t){if(i.texture===O.WHITE&&!i.fill)return H.shared.setValue(i.color).toHex();if(i.fill){if(i.fill instanceof Jr){const e=i.fill,r=t.createPattern(e.texture.source.resource,"repeat"),s=e.transform.copyTo(V.shared);return s.scale(e.texture.frame.width,e.texture.frame.height),r.setTransform(s),r}else if(i.fill instanceof Le){const e=i.fill;if(e.type==="linear"){const r=t.createLinearGradient(e.x0,e.y0,e.x1,e.y1);return e.gradientStops.forEach(s=>{r.addColorStop(s.offset,H.shared.setValue(s.color).toHex())}),r}}}else{const e=t.createPattern(i.texture.source.resource,"repeat"),r=i.matrix.copyTo(V.shared);return r.scale(i.texture.frame.width,i.texture.frame.height),e.setTransform(r),e}return at("FillStyle not recognised",i),"red"}class os extends vt{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return E(D,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return E(D,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return E(D,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return E(D,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return E(D,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners();for(const e in this.chars)this.chars[e].texture.destroy();this.chars=null,t&&(this.pages.forEach(e=>e.texture.destroy(!0)),this.pages=null)}}function hs(i){if(i==="")return[];typeof i=="string"&&(i=[i]);const t=[];for(let e=0,r=i.length;e<r;e++){const s=i[e];if(Array.isArray(s)){if(s.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);if(s[0].length===0||s[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=s[0].charCodeAt(0),a=s[1].charCodeAt(0);if(a<n)throw new Error("[BitmapFont]: Invalid character range.");for(let o=n,h=a;o<=h;o++)t.push(String.fromCharCode(o))}else t.push(...Array.from(s))}if(t.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}class fr extends os{constructor(t){super(),this.resolution=1,this.pages=[],this._padding=4,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const e=t,r=e.style.clone();e.overrideFill&&(r._fill.color=16777215,r._fill.alpha=1,r._fill.texture=O.WHITE,r._fill.fill=null);const s=r.fontSize;r.fontSize=this.baseMeasurementFontSize;const n=Yt(r);e.overrideSize?r._stroke&&(r._stroke.width*=this.baseRenderedFontSize/s):r.fontSize=this.baseRenderedFontSize=s,this._style=r,this._skipKerning=e.skipKerning??!1,this.resolution=e.resolution??1,this._padding=e.padding??4,this.fontMetrics=et.measureFont(n),this.lineHeight=r.lineHeight||this.fontMetrics.fontSize||r.fontSize}ensureCharacters(t){var m,g;const e=hs(t).filter(_=>!this._currentChars.includes(_)).filter((_,x,y)=>y.indexOf(_)===x);if(!e.length)return;this._currentChars=[...this._currentChars,...e];let r;this._currentPageIndex===-1?r=this._nextPage():r=this.pages[this._currentPageIndex];let{canvas:s,context:n}=r.canvasAndContext,a=r.texture.source;const o=this._style;let h=this._currentX,l=this._currentY;const c=this.baseRenderedFontSize/this.baseMeasurementFontSize,u=this._padding*c,d=o.fontStyle==="italic"?2:1;let f=0,p=!1;for(let _=0;_<e.length;_++){const x=e[_],y=et.measureText(x,o,s,!1);y.lineHeight=y.height;const b=d*y.width*c,P=y.height*c,k=b+u*2,T=P+u*2;if(p=!1,x!==`
`&&x!=="\r"&&x!=="	"&&x!==" "&&(p=!0,f=Math.ceil(Math.max(T,f))),h+k>512&&(l+=f,f=T,h=0,l+f>512)){a.update();const S=this._nextPage();s=S.canvasAndContext.canvas,n=S.canvasAndContext.context,a=S.texture.source,l=0}const v=b/c-(((m=o.dropShadow)==null?void 0:m.distance)??0)-(((g=o._stroke)==null?void 0:g.width)??0);if(this.chars[x]={id:x.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:v,kerning:{}},p){this._drawGlyph(n,y,h+u,l+u,c,o);const S=a.width*c,w=a.height*c,G=new Q(h/S*a.width,l/w*a.height,k/S*a.width,T/w*a.height);this.chars[x].texture=new O({source:a,frame:G}),h+=Math.ceil(k)}}a.update(),this._currentX=h,this._currentY=l,this._skipKerning&&this._applyKerning(e,n)}get pageTextures(){return E(D,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const r=this._measureCache;for(let s=0;s<t.length;s++){const n=t[s];for(let a=0;a<this._currentChars.length;a++){const o=this._currentChars[a];let h=r[n];h||(h=r[n]=e.measureText(n).width);let l=r[o];l||(l=r[o]=e.measureText(o).width);let c=e.measureText(n+o).width,u=c-(h+l);u&&(this.chars[n].kerning[o]=u),c=e.measureText(n+o).width,u=c-(h+l),u&&(this.chars[o].kerning[n]=u)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=ft.getOptimalCanvasAndContext(512,512,t);this._setupContext(e.context,this._style,t);const r=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),s=new O({source:new Rr({resource:e.canvas,resolution:r,alphaMode:"premultiply-alpha-on-upload"})}),n={canvasAndContext:e,texture:s};return this.pages[this._currentPageIndex]=n,n}_setupContext(t,e,r){e.fontSize=this.baseRenderedFontSize,t.scale(r,r),t.font=Yt(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const s=e._stroke,n=(s==null?void 0:s.width)??0;if(s&&(t.lineWidth=n,t.lineJoin=s.join,t.miterLimit=s.miterLimit,t.strokeStyle=Xt(s,t)),e._fill&&(t.fillStyle=Xt(e._fill,t)),e.dropShadow){const a=e.dropShadow,o=H.shared.setValue(a.color).toArray(),h=a.blur*r,l=a.distance*r;t.shadowColor=`rgba(${o[0]*255},${o[1]*255},${o[2]*255},${a.alpha})`,t.shadowBlur=h,t.shadowOffsetX=Math.cos(a.angle)*l,t.shadowOffsetY=Math.sin(a.angle)*l}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,r,s,n,a){const o=e.text,h=e.fontProperties,l=a._stroke,c=((l==null?void 0:l.width)??0)*n,u=r+c/2,d=s-c/2,f=h.descent*n,p=e.lineHeight*n;a.stroke&&c&&t.strokeText(o,u,d+p-f),a._fill&&t.fillText(o,u,d+p-f)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:r}=this.pages[t];ft.returnCanvasAndContext(e),r.destroy(!0)}this.pages=null}}function cs(i,t,e){const r={width:0,height:0,offsetY:0,scale:t.fontSize/e.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};r.offsetY=e.baseLineOffset;let s=r.lines[0],n=null,a=!0;const o={spaceWord:!1,width:0,start:0,index:0,positions:[],chars:[]},h=f=>{const p=s.width;for(let m=0;m<o.index;m++){const g=f.positions[m];s.chars.push(f.chars[m]),s.charPositions.push(g+p)}s.width+=f.width,a=!1,o.width=0,o.index=0,o.chars.length=0},l=()=>{let f=s.chars.length-1,p=s.chars[f];for(;p===" ";)s.width-=e.chars[p].xAdvance,p=s.chars[--f];r.width=Math.max(r.width,s.width),s={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},a=!0,r.lines.push(s),r.height+=e.lineHeight},c=e.baseMeasurementFontSize/t.fontSize,u=t.letterSpacing*c,d=t.wordWrapWidth*c;for(let f=0;f<i.length+1;f++){let p;const m=f===i.length;m||(p=i[f]);const g=e.chars[p]||e.chars[" "];if(/(?:\s)/.test(p)||p==="\r"||p===`
`||m){if(!a&&t.wordWrap&&s.width+o.width-u>d?(l(),h(o),m||s.charPositions.push(0)):(o.start=s.width,h(o),m||s.charPositions.push(0)),p==="\r"||p===`
`)s.width!==0&&l();else if(!m){const b=g.xAdvance+(g.kerning[n]||0)+u;s.width+=b,s.spaceWidth=b,s.spacesIndex.push(s.charPositions.length),s.chars.push(p)}}else{const y=g.kerning[n]||0,b=g.xAdvance+y+u;o.positions[o.index++]=o.width+y,o.chars.push(p),o.width+=b}n=p}return l(),t.align==="center"?xn(r):t.align==="right"?_n(r):t.align==="justify"&&yn(r),r}function xn(i){for(let t=0;t<i.lines.length;t++){const e=i.lines[t],r=i.width/2-e.width/2;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=r}}function _n(i){for(let t=0;t<i.lines.length;t++){const e=i.lines[t],r=i.width-e.width;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=r}}function yn(i){const t=i.width;for(let e=0;e<i.lines.length;e++){const r=i.lines[e];let s=0,n=r.spacesIndex[s++],a=0;const o=r.spacesIndex.length,l=(t-r.width)/o;for(let c=0;c<r.charPositions.length;c++)c===n&&(n=r.spacesIndex[s++],a+=l),r.charPositions[c]+=a}}class bn{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(t,e){var a;let r=`${e.fontFamily}-bitmap`,s=!0;if(e._fill.fill&&(r+=e._fill.fill.uid,s=!1),!X.has(r)){const o=new fr({style:e,overrideFill:s,overrideSize:!0,...this.defaultOptions});o.once("destroy",()=>X.remove(r)),X.set(r,o)}const n=X.get(r);return(a=n.ensureCharacters)==null||a.call(n,t),n}getLayout(t,e){const r=this.getFont(t,e);return cs([...t],e,r)}measureText(t,e){return this.getLayout(t,e)}install(...t){var l,c,u,d;let e=t[0];typeof e=="string"&&(e={name:e,style:t[1],chars:(l=t[2])==null?void 0:l.chars,resolution:(c=t[2])==null?void 0:c.resolution,padding:(u=t[2])==null?void 0:u.padding,skipKerning:(d=t[2])==null?void 0:d.skipKerning},E(D,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const r=e==null?void 0:e.name;if(!r)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const s=e.style,n=s instanceof Tt?s:new Tt(s),a=n._fill.fill!==null&&n._fill.fill!==void 0,o=new fr({style:n,overrideFill:a,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1}),h=hs(e.chars);return o.ensureCharacters(h.join("")),X.set(`${r}-bitmap`,o),o.once("destroy",()=>X.remove(`${r}-bitmap`)),o}uninstall(t){const e=`${t}-bitmap`,r=X.get(e);r&&(X.remove(e),r.destroy())}}const Ae=new bn;function Sn(i){const t=i._stroke,e=i._fill,s=[`div { ${[`color: ${H.shared.setValue(e.color).toHex()}`,`font-size: ${i.fontSize}px`,`font-family: ${i.fontFamily}`,`font-weight: ${i.fontWeight}`,`font-style: ${i.fontStyle}`,`font-variant: ${i.fontVariant}`,`letter-spacing: ${i.letterSpacing}px`,`text-align: ${i.align}`,`padding: ${i.padding}px`,`white-space: ${i.whiteSpace==="pre"&&i.wordWrap?"pre-wrap":i.whiteSpace}`,...i.lineHeight?[`line-height: ${i.lineHeight}px`]:[],...i.wordWrap?[`word-wrap: ${i.breakWords?"break-all":"break-word"}`,`max-width: ${i.wordWrapWidth}px`]:[],...t?[us(t)]:[],...i.dropShadow?[ls(i.dropShadow)]:[],...i.cssOverrides].join(";")} }`];return wn(i.tagStyles,s),s.join(" ")}function ls(i){const t=H.shared.setValue(i.color).setAlpha(i.alpha).toHexa(),e=Math.round(Math.cos(i.angle)*i.distance),r=Math.round(Math.sin(i.angle)*i.distance),s=`${e}px ${r}px`;return i.blur>0?`text-shadow: ${s} ${i.blur}px ${t}`:`text-shadow: ${s} ${t}`}function us(i){return[`-webkit-text-stroke-width: ${i.width}px`,`-webkit-text-stroke-color: ${H.shared.setValue(i.color).toHex()}`,`text-stroke-width: ${i.width}px`,`text-stroke-color: ${H.shared.setValue(i.color).toHex()}`,"paint-order: stroke"].join(";")}const pr={fontSize:"font-size: {{VALUE}}px",fontFamily:"font-family: {{VALUE}}",fontWeight:"font-weight: {{VALUE}}",fontStyle:"font-style: {{VALUE}}",fontVariant:"font-variant: {{VALUE}}",letterSpacing:"letter-spacing: {{VALUE}}px",align:"text-align: {{VALUE}}",padding:"padding: {{VALUE}}px",whiteSpace:"white-space: {{VALUE}}",lineHeight:"line-height: {{VALUE}}px",wordWrapWidth:"max-width: {{VALUE}}px"},gr={fill:i=>`color: ${H.shared.setValue(i).toHex()}`,breakWords:i=>`word-wrap: ${i?"break-all":"break-word"}`,stroke:us,dropShadow:ls};function wn(i,t){for(const e in i){const r=i[e],s=[];for(const n in r)gr[n]?s.push(gr[n](r[n])):pr[n]&&s.push(pr[n].replace("{{VALUE}}",r[n]));t.push(`${e} { ${s.join(";")} }`)}}class Ve extends Tt{constructor(t={}){super(t),this._cssOverrides=[],this.cssOverrides??(this.cssOverrides=t.cssOverrides),this.tagStyles=t.tagStyles??{}}set cssOverrides(t){this._cssOverrides=t instanceof Array?t:[t],this.update()}get cssOverrides(){return this._cssOverrides}_generateKey(){return this._styleKey=ns(this)+this._cssOverrides.join("-"),this._styleKey}update(){this._cssStyle=null,super.update()}clone(){return new Ve({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,cssOverrides:this.cssOverrides})}get cssStyle(){return this._cssStyle||(this._cssStyle=Sn(this)),this._cssStyle}addOverride(...t){const e=t.filter(r=>!this.cssOverrides.includes(r));e.length>0&&(this.cssOverrides.push(...e),this.update())}removeOverride(...t){const e=t.filter(r=>this.cssOverrides.includes(r));e.length>0&&(this.cssOverrides=this.cssOverrides.filter(r=>!e.includes(r)),this.update())}set fill(t){typeof t!="string"&&typeof t!="number"&&at("[HTMLTextStyle] only color fill is not supported by HTMLText"),super.fill=t}set stroke(t){t&&typeof t!="string"&&typeof t!="number"&&at("[HTMLTextStyle] only color stroke is not supported by HTMLText"),super.stroke=t}}const mr="http://www.w3.org/2000/svg",xr="http://www.w3.org/1999/xhtml";class ds{constructor(){this.svgRoot=document.createElementNS(mr,"svg"),this.foreignObject=document.createElementNS(mr,"foreignObject"),this.domElement=document.createElementNS(xr,"div"),this.styleElement=document.createElementNS(xr,"style"),this.image=new Image;const{foreignObject:t,svgRoot:e,styleElement:r,domElement:s}=this;t.setAttribute("width","10000"),t.setAttribute("height","10000"),t.style.overflow="hidden",e.appendChild(t),t.appendChild(r),t.appendChild(s)}}let _r;function Tn(i,t,e,r){r=r||_r||(_r=new ds);const{domElement:s,styleElement:n,svgRoot:a}=r;s.innerHTML=`<style>${t.cssStyle}</style><div>${i}</div>`,s.setAttribute("style","transform-origin: top left; display: inline-block"),e&&(n.textContent=e),document.body.appendChild(a);const o=s.getBoundingClientRect();a.remove();const h=et.measureFont(t.fontStyle).descent;return{width:o.width,height:o.height+h}}function yr(i,t,e){if(i)for(const r in i){const s=r.toLocaleLowerCase(),n=t[s];if(n){let a=i[r];r==="header"&&(a=a.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),e&&n.push(`//----${e}----//`),n.push(a)}else at(`${r} placement hook does not exist in shader`)}}const vn=/\{\{(.*?)\}\}/g;function br(i){var r;const t={};return(((r=i.match(vn))==null?void 0:r.map(s=>s.replace(/[{()}]/g,"")))??[]).forEach(s=>{t[s]=[]}),t}function Sr(i,t){let e;const r=/@in\s+([^;]+);/g;for(;(e=r.exec(i))!==null;)t.push(e[1])}function wr(i,t,e=!1){const r=[];Sr(t,r),i.forEach(o=>{o.header&&Sr(o.header,r)});const s=r;e&&s.sort();const n=s.map((o,h)=>`       @location(${h}) ${o},`).join(`
`);let a=t.replace(/@in\s+[^;]+;\s*/g,"");return a=a.replace("{{in}}",`
${n}
`),a}function Tr(i,t){let e;const r=/@out\s+([^;]+);/g;for(;(e=r.exec(i))!==null;)t.push(e[1])}function Pn(i){const e=/\b(\w+)\s*:/g.exec(i);return e?e[1]:""}function Cn(i){const t=/@.*?\s+/g;return i.replace(t,"")}function Mn(i,t){const e=[];Tr(t,e),i.forEach(h=>{h.header&&Tr(h.header,e)});let r=0;const s=e.sort().map(h=>h.indexOf("builtin")>-1?h:`@location(${r++}) ${h}`).join(`,
`),n=e.sort().map(h=>`       var ${Cn(h)};`).join(`
`),a=`return VSOutput(
                ${e.sort().map(h=>` ${Pn(h)}`).join(`,
`)});`;let o=t.replace(/@out\s+[^;]+;\s*/g,"");return o=o.replace("{{struct}}",`
${s}
`),o=o.replace("{{start}}",`
${n}
`),o=o.replace("{{return}}",`
${a}
`),o}function vr(i,t){let e=i;for(const r in t){const s=t[r];s.join(`
`).length?e=e.replace(`{{${r}}}`,`//-----${r} START-----//
${s.join(`
`)}
//----${r} FINISH----//`):e=e.replace(`{{${r}}}`,"")}return e}const it=Object.create(null),xe=new Map;let kn=0;function Bn({template:i,bits:t}){const e=fs(i,t);if(it[e])return it[e];const{vertex:r,fragment:s}=Fn(i,t);return it[e]=ps(r,s,t),it[e]}function An({template:i,bits:t}){const e=fs(i,t);return it[e]||(it[e]=ps(i.vertex,i.fragment,t)),it[e]}function Fn(i,t){const e=t.map(a=>a.vertex).filter(a=>!!a),r=t.map(a=>a.fragment).filter(a=>!!a);let s=wr(e,i.vertex,!0);s=Mn(e,s);const n=wr(r,i.fragment,!0);return{vertex:s,fragment:n}}function fs(i,t){return t.map(e=>(xe.has(e)||xe.set(e,kn++),xe.get(e))).sort((e,r)=>e-r).join("-")+i.vertex+i.fragment}function ps(i,t,e){const r=br(i),s=br(t);return e.forEach(n=>{yr(n.vertex,r,n.name),yr(n.fragment,s,n.name)}),{vertex:vr(i,r),fragment:vr(t,s)}}const Rn=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,In=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`,zn=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,Gn=`
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`,Un={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},En={name:"global-uniforms-bit",vertex:{header:`
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}};function gs({bits:i,name:t}){const e=Bn({template:{fragment:In,vertex:Rn},bits:[Un,...i]});return qt.from({name:t,vertex:{source:e.vertex,entryPoint:"main"},fragment:{source:e.fragment,entryPoint:"main"}})}function ms({bits:i,name:t}){return new Gr({name:t,...An({template:{vertex:zn,fragment:Gn},bits:[En,...i]})})}const Dn={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},Wn={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},_e={};function Ln(i){const t=[];if(i===1)t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),t.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let e=0;for(let r=0;r<i;r++)t.push(`@group(1) @binding(${e++}) var textureSource${r+1}: texture_2d<f32>;`),t.push(`@group(1) @binding(${e++}) var textureSampler${r+1}: sampler;`)}return t.join(`
`)}function Hn(i){const t=[];if(i===1)t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{t.push("switch vTextureId {");for(let e=0;e<i;e++)e===i-1?t.push("  default:{"):t.push(`  case ${e}:{`),t.push(`      outColor = textureSampleGrad(textureSource${e+1}, textureSampler${e+1}, vUV, uvDx, uvDy);`),t.push("      break;}");t.push("}")}return t.join(`
`)}function On(i){return _e[i]||(_e[i]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;
    
                ${Ln(St())}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${Hn(St())}
            `}}),_e[i]}const ye={};function $n(i){const t=[];for(let e=0;e<i;e++)e>0&&t.push("else"),e<i-1&&t.push(`if(vTextureId < ${e}.5)`),t.push("{"),t.push(`	outColor = texture(uTextures[${e}], vUV);`),t.push("}");return t.join(`
`)}function Vn(i){return ye[i]||(ye[i]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;
    
                uniform sampler2D uTextures[${i}];
              
            `,main:`
    
                ${$n(St())}
            `}}),ye[i]}const xs={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},_s={name:"round-pixels-bit",vertex:{header:`   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},Pr={};function Nn(i){let t=Pr[i];if(t)return t;const e=new Int32Array(i);for(let r=0;r<i;r++)e[r]=r;return t=Pr[i]=new gt({uTextures:{value:e,type:"i32",size:i}},{isStatic:!0}),t}const Nt={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}};({...Nt,vertex:{...Nt.vertex,header:Nt.vertex.header.replace("group(1)","group(2)")}});const jn={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}};class ys{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(t,e,r,s){const n=this.renderable,a=this.texture,o=n.groupTransform,h=o.a,l=o.b,c=o.c,u=o.d,d=o.tx,f=o.ty,p=this.bounds,m=p.maxX,g=p.minX,_=p.maxY,x=p.minY,y=a.uvs,b=n.groupColorAlpha,P=s<<16|this.roundPixels&65535;t[r+0]=h*g+c*x+d,t[r+1]=u*x+l*g+f,t[r+2]=y.x0,t[r+3]=y.y0,e[r+4]=b,e[r+5]=P,t[r+6]=h*m+c*x+d,t[r+7]=u*x+l*m+f,t[r+8]=y.x1,t[r+9]=y.y1,e[r+10]=b,e[r+11]=P,t[r+12]=h*m+c*_+d,t[r+13]=u*_+l*m+f,t[r+14]=y.x2,t[r+15]=y.y2,e[r+16]=b,e[r+17]=P,t[r+18]=h*g+c*_+d,t[r+19]=u*_+l*g+f,t[r+20]=y.x3,t[r+21]=y.y3,e[r+22]=b,e[r+23]=P}packIndex(t,e,r){t[e]=r+0,t[e+1]=r+1,t[e+2]=r+2,t[e+3]=r+0,t[e+4]=r+2,t[e+5]=r+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}function Ne(i,t,e){const r=(i>>24&255)/255;t[e++]=(i&255)/255*r,t[e++]=(i>>8&255)/255*r,t[e++]=(i>>16&255)/255*r,t[e++]=r}class bs{constructor(t,e){this.state=Lr.for2d(),this._graphicsBatchesHash=Object.create(null),this.renderer=t,this._adaptor=e,this._adaptor.init()}validateRenderable(t){const e=t.context,r=!!this._graphicsBatchesHash[t.uid],s=this.renderer.graphicsContext.updateGpuContext(e);return!!(s.isBatchable||r!==s.isBatchable)}addRenderable(t,e){const r=this.renderer.graphicsContext.updateGpuContext(t.context);t._didGraphicsUpdate&&(t._didGraphicsUpdate=!1,this._rebuild(t)),r.isBatchable?this._addToBatcher(t,e):(this.renderer.renderPipes.batch.break(e),e.add(t))}updateRenderable(t){const e=this._graphicsBatchesHash[t.uid];if(e)for(let r=0;r<e.length;r++){const s=e[r];s.batcher.updateElement(s)}}destroyRenderable(t){this._graphicsBatchesHash[t.uid]&&this._removeBatchForRenderable(t.uid)}execute(t){if(!t.isRenderable)return;const e=this.renderer,r=t.context;if(!e.graphicsContext.getGpuContext(r).batches.length)return;const n=r.customShader||this._adaptor.shader;this.state.blendMode=t.groupBlendMode;const a=n.resources.localUniforms.uniforms;a.uTransformMatrix=t.groupTransform,a.uRound=e._roundPixels|t._roundPixels,Ne(t.groupColorAlpha,a.uColor,0),this._adaptor.execute(this,t)}_rebuild(t){const e=!!this._graphicsBatchesHash[t.uid],r=this.renderer.graphicsContext.updateGpuContext(t.context);e&&this._removeBatchForRenderable(t.uid),r.isBatchable&&this._initBatchesForRenderable(t),t.batched=r.isBatchable}_addToBatcher(t,e){const r=this.renderer.renderPipes.batch,s=this._getBatchesForRenderable(t);for(let n=0;n<s.length;n++){const a=s[n];r.addToBatch(a,e)}}_getBatchesForRenderable(t){return this._graphicsBatchesHash[t.uid]||this._initBatchesForRenderable(t)}_initBatchesForRenderable(t){const e=t.context,r=this.renderer.graphicsContext.getGpuContext(e),s=this.renderer._roundPixels|t._roundPixels,n=r.batches.map(a=>{const o=W.get(Ue);return a.copyTo(o),o.renderable=t,o.roundPixels=s,o});return this._graphicsBatchesHash[t.uid]===void 0&&t.on("destroyed",()=>{this.destroyRenderable(t)}),this._graphicsBatchesHash[t.uid]=n,n}_removeBatchForRenderable(t){this._graphicsBatchesHash[t].forEach(e=>{W.return(e)}),this._graphicsBatchesHash[t]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const t in this._graphicsBatchesHash)this._removeBatchForRenderable(t);this._graphicsBatchesHash=null}}bs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"graphics"};const Ss=class ws extends Oe{constructor(...t){super({});let e=t[0]??{};typeof e=="number"&&(E(D,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),e={width:e,height:t[1],verticesX:t[2],verticesY:t[3]}),this.build(e)}build(t){t={...ws.defaultOptions,...t},this.verticesX=this.verticesX??t.verticesX,this.verticesY=this.verticesY??t.verticesY,this.width=this.width??t.width,this.height=this.height??t.height;const e=this.verticesX*this.verticesY,r=[],s=[],n=[],a=this.verticesX-1,o=this.verticesY-1,h=this.width/a,l=this.height/o;for(let u=0;u<e;u++){const d=u%this.verticesX,f=u/this.verticesX|0;r.push(d*h,f*l),s.push(d/a,f/o)}const c=a*o;for(let u=0;u<c;u++){const d=u%a,f=u/a|0,p=f*this.verticesX+d,m=f*this.verticesX+d+1,g=(f+1)*this.verticesX+d,_=(f+1)*this.verticesX+d+1;n.push(p,m,g,m,_,g)}this.buffers[0].data=new Float32Array(r),this.buffers[1].data=new Float32Array(s),this.indexBuffer.data=new Uint32Array(n),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};Ss.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let Yn=Ss;class je{constructor(){this.batcher=null,this.batch=null,this.roundPixels=0,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}get blendMode(){return this.mesh.groupBlendMode}reset(){this.mesh=null,this.texture=null,this.batcher=null,this.batch=null}packIndex(t,e,r){const s=this.geometry.indices;for(let n=0;n<s.length;n++)t[e++]=s[n]+r}packAttributes(t,e,r,s){const n=this.mesh,a=this.geometry,o=n.groupTransform,h=s<<16|this.roundPixels&65535,l=o.a,c=o.b,u=o.c,d=o.d,f=o.tx,p=o.ty,m=a.positions,g=a.getBuffer("aUV"),_=g.data;let x=_;const y=this.texture.textureMatrix;y.isSimple||(x=this._transformedUvs,(this._textureMatrixUpdateId!==y._updateID||this._uvUpdateId!==g._updateID)&&((!x||x.length<_.length)&&(x=this._transformedUvs=new Float32Array(_.length)),this._textureMatrixUpdateId=y._updateID,this._uvUpdateId=g._updateID,y.multiplyUvs(_,x)));const b=n.groupColorAlpha;for(let P=0;P<m.length;P+=2){const k=m[P],T=m[P+1];t[r]=l*k+u*T+f,t[r+1]=c*k+d*T+p,t[r+2]=x[P],t[r+3]=x[P+1],e[r+4]=b,e[r+5]=h,r+=6}}get vertexSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}class Ts{constructor(t,e){this.localUniforms=new gt({uTransformMatrix:{value:new V,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new _t({0:this.localUniforms}),this._meshDataHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this.renderer=t,this._adaptor=e,this._adaptor.init()}validateRenderable(t){const e=this._getMeshData(t),r=e.batched,s=t.batched;if(e.batched=s,r!==s)return!0;if(s){const n=t._geometry;if(n.indices.length!==e.indexSize||n.positions.length!==e.vertexSize)return e.indexSize=n.indices.length,e.vertexSize=n.positions.length,!0;const a=this._getBatchableMesh(t),o=t.texture;if(a.texture._source!==o._source&&a.texture._source!==o._source)return!a.batcher.checkAndUpdateTexture(a,o)}return!1}addRenderable(t,e){const r=this.renderer.renderPipes.batch,{batched:s}=this._getMeshData(t);if(s){const n=this._getBatchableMesh(t);n.texture=t._texture,n.geometry=t._geometry,r.addToBatch(n)}else r.break(e),e.add({renderPipeId:"mesh",mesh:t})}updateRenderable(t){if(t.batched){const e=this._gpuBatchableMeshHash[t.uid];e.texture=t._texture,e.geometry=t._geometry,e.batcher.updateElement(e)}}destroyRenderable(t){this._meshDataHash[t.uid]=null;const e=this._gpuBatchableMeshHash[t.uid];e&&(W.return(e),this._gpuBatchableMeshHash[t.uid]=null)}execute({mesh:t}){if(!t.isRenderable)return;t.state.blendMode=t.groupBlendMode;const e=this.localUniforms;e.uniforms.uTransformMatrix=t.groupTransform,e.uniforms.uRound=this.renderer._roundPixels|t._roundPixels,e.update(),Ne(t.groupColorAlpha,e.uniforms.uColor,0),this._adaptor.execute(this,t)}_getMeshData(t){return this._meshDataHash[t.uid]||this._initMeshData(t)}_initMeshData(t){var e,r;return this._meshDataHash[t.uid]={batched:t.batched,indexSize:(e=t._geometry.indices)==null?void 0:e.length,vertexSize:(r=t._geometry.positions)==null?void 0:r.length},t.on("destroyed",()=>{this.destroyRenderable(t)}),this._meshDataHash[t.uid]}_getBatchableMesh(t){return this._gpuBatchableMeshHash[t.uid]||this._initBatchableMesh(t)}_initBatchableMesh(t){const e=W.get(je);return e.mesh=t,e.texture=t._texture,e.roundPixels=this.renderer._roundPixels|t._roundPixels,this._gpuBatchableMeshHash[t.uid]=e,e.mesh=t,e}destroy(){for(const t in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[t]&&W.return(this._gpuBatchableMeshHash[t]);this._gpuBatchableMeshHash=null,this._meshDataHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}Ts.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"mesh"};const vs=class Ps extends Yn{constructor(t={}){t={...Ps.defaultOptions,...t},super({width:t.width,height:t.height,verticesX:4,verticesY:4}),this.update(t)}update(t){this.width=t.width??this.width,this.height=t.height??this.height,this._originalWidth=t.originalWidth??this._originalWidth,this._originalHeight=t.originalHeight??this._originalHeight,this._leftWidth=t.leftWidth??this._leftWidth,this._rightWidth=t.rightWidth??this._rightWidth,this._topHeight=t.topHeight??this._topHeight,this._bottomHeight=t.bottomHeight??this._bottomHeight,this.updateUvs(),this.updatePositions()}updatePositions(){const t=this.positions,e=this._leftWidth+this._rightWidth,r=this.width>e?1:this.width/e,s=this._topHeight+this._bottomHeight,n=this.height>s?1:this.height/s,a=Math.min(r,n);t[9]=t[11]=t[13]=t[15]=this._topHeight*a,t[17]=t[19]=t[21]=t[23]=this.height-this._bottomHeight*a,t[25]=t[27]=t[29]=t[31]=this.height,t[2]=t[10]=t[18]=t[26]=this._leftWidth*a,t[4]=t[12]=t[20]=t[28]=this.width-this._rightWidth*a,t[6]=t[14]=t[22]=t[30]=this.width,this.getBuffer("aPosition").update()}updateUvs(){const t=this.uvs;t[0]=t[8]=t[16]=t[24]=0,t[1]=t[3]=t[5]=t[7]=0,t[6]=t[14]=t[22]=t[30]=1,t[25]=t[27]=t[29]=t[31]=1;const e=1/this._originalWidth,r=1/this._originalHeight;t[2]=t[10]=t[18]=t[26]=e*this._leftWidth,t[9]=t[11]=t[13]=t[15]=r*this._topHeight,t[4]=t[12]=t[20]=t[28]=1-e*this._rightWidth,t[17]=t[19]=t[21]=t[23]=1-r*this._bottomHeight,this.getBuffer("aUV").update()}};vs.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let Xn=vs;class Cs{constructor(t){this._gpuSpriteHash=Object.create(null),this._renderer=t}addRenderable(t,e){const r=this._getGpuSprite(t);t._didSpriteUpdate&&this._updateBatchableSprite(t,r),this._renderer.renderPipes.batch.addToBatch(r)}updateRenderable(t){const e=this._gpuSpriteHash[t.uid];t._didSpriteUpdate&&this._updateBatchableSprite(t,e),e.batcher.updateElement(e)}validateRenderable(t){const e=t._texture,r=this._getGpuSprite(t);return r.texture._source!==e._source?!r.batcher.checkAndUpdateTexture(r,e):!1}destroyRenderable(t){const e=this._gpuSpriteHash[t.uid];W.return(e),this._gpuSpriteHash[t.uid]=null}_updateBatchableSprite(t,e){t._didSpriteUpdate=!1,e.geometry.update(t),e.texture=t._texture}_getGpuSprite(t){return this._gpuSpriteHash[t.uid]||this._initGPUSprite(t)}_initGPUSprite(t){const e=new je;return e.geometry=new Xn,e.mesh=t,e.texture=t._texture,e.roundPixels=this._renderer._roundPixels|t._roundPixels,this._gpuSpriteHash[t.uid]=e,t.on("destroyed",()=>{this.destroyRenderable(t)}),e}destroy(){for(const t in this._gpuSpriteHash)this._gpuSpriteHash[t].geometry.destroy();this._gpuSpriteHash=null,this._renderer=null}}Cs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"nineSliceSprite"};const qn={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},Kn={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,main:`
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `}};let be,Se;class Qn extends Kt{constructor(){be??(be=gs({name:"tiling-sprite-shader",bits:[Nt,qn,xs]})),Se??(Se=ms({name:"tiling-sprite-shader",bits:[jn,Kn,_s]}));const t=new gt({uMapCoord:{value:new V,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new V,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:Se,gpuProgram:be,resources:{localUniforms:new gt({uTransformMatrix:{value:new V,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:t,uTexture:O.EMPTY.source,uSampler:O.EMPTY.source.style}})}updateUniforms(t,e,r,s,n,a){const o=this.resources.tilingUniforms,h=a.width,l=a.height,c=a.textureMatrix,u=o.uniforms.uTextureTransform;u.set(r.a*h/t,r.b*h/e,r.c*l/t,r.d*l/e,r.tx/t,r.ty/e),u.invert(),o.uniforms.uMapCoord=c.mapCoord,o.uniforms.uClampFrame=c.uClampFrame,o.uniforms.uClampOffset=c.uClampOffset,o.uniforms.uTextureTransform=u,o.uniforms.uSizeAnchor[0]=t,o.uniforms.uSizeAnchor[1]=e,o.uniforms.uSizeAnchor[2]=s,o.uniforms.uSizeAnchor[3]=n,a&&(this.resources.uTexture=a.source,this.resources.uSampler=a.source.style)}}class Zn extends Oe{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}function Jn(i,t){const e=i.anchor.x,r=i.anchor.y;t[0]=-e*i.width,t[1]=-r*i.height,t[2]=(1-e)*i.width,t[3]=-r*i.height,t[4]=(1-e)*i.width,t[5]=(1-r)*i.height,t[6]=-e*i.width,t[7]=(1-r)*i.height}function ta(i,t,e,r){let s=0;const n=i.length/t,a=r.a,o=r.b,h=r.c,l=r.d,c=r.tx,u=r.ty;for(e*=t;s<n;){const d=i[e],f=i[e+1];i[e]=a*d+h*f+c,i[e+1]=o*d+l*f+u,e+=t,s++}}function ea(i,t){const e=i.texture,r=e.frame.width,s=e.frame.height;let n=0,a=0;i._applyAnchorToTexture&&(n=i.anchor.x,a=i.anchor.y),t[0]=t[6]=-n,t[2]=t[4]=1-n,t[1]=t[3]=-a,t[5]=t[7]=1-a;const o=V.shared;o.copyFrom(i._tileTransform.matrix),o.tx/=i.width,o.ty/=i.height,o.invert(),o.scale(i.width/r,i.height/s),ta(t,2,0,o)}const $t=new Zn;class Ms{constructor(t){this._tilingSpriteDataHash=Object.create(null),this._renderer=t}validateRenderable(t){const e=this._getTilingSpriteData(t),r=e.canBatch;this._updateCanBatch(t);const s=e.canBatch;if(s&&s===r){const{batchableMesh:n}=e;if(n.texture._source!==t.texture._source)return!n.batcher.checkAndUpdateTexture(n,t.texture)}return r!==s}addRenderable(t,e){const r=this._renderer.renderPipes.batch;this._updateCanBatch(t);const s=this._getTilingSpriteData(t),{geometry:n,canBatch:a}=s;if(a){s.batchableMesh||(s.batchableMesh=new je);const o=s.batchableMesh;t._didTilingSpriteUpdate&&(t._didTilingSpriteUpdate=!1,this._updateBatchableMesh(t),o.geometry=n,o.mesh=t,o.texture=t._texture),o.roundPixels=this._renderer._roundPixels|t._roundPixels,r.addToBatch(o)}else r.break(e),s.shader||(s.shader=new Qn),this.updateRenderable(t),e.add(t)}execute(t){const{shader:e}=this._tilingSpriteDataHash[t.uid];e.groups[0]=this._renderer.globalUniforms.bindGroup;const r=e.resources.localUniforms.uniforms;r.uTransformMatrix=t.groupTransform,r.uRound=this._renderer._roundPixels|t._roundPixels,Ne(t.groupColorAlpha,r.uColor,0),this._renderer.encoder.draw({geometry:$t,shader:e,state:Lr.default2d})}updateRenderable(t){const e=this._getTilingSpriteData(t),{canBatch:r}=e;if(r){const{batchableMesh:s}=e;t._didTilingSpriteUpdate&&this._updateBatchableMesh(t),s.batcher.updateElement(s)}else if(t._didTilingSpriteUpdate){const{shader:s}=e;s.updateUniforms(t.width,t.height,t._tileTransform.matrix,t.anchor.x,t.anchor.y,t.texture)}t._didTilingSpriteUpdate=!1}destroyRenderable(t){var r;const e=this._getTilingSpriteData(t);e.batchableMesh=null,(r=e.shader)==null||r.destroy(),this._tilingSpriteDataHash[t.uid]=null}_getTilingSpriteData(t){return this._tilingSpriteDataHash[t.uid]||this._initTilingSpriteData(t)}_initTilingSpriteData(t){const e=new Oe({indices:$t.indices,positions:$t.positions.slice(),uvs:$t.uvs.slice()});return this._tilingSpriteDataHash[t.uid]={canBatch:!0,renderable:t,geometry:e},t.on("destroyed",()=>{this.destroyRenderable(t)}),this._tilingSpriteDataHash[t.uid]}_updateBatchableMesh(t){const e=this._getTilingSpriteData(t),{geometry:r}=e,s=t.texture.source.style;s.addressMode!=="repeat"&&(s.addressMode="repeat",s.update()),ea(t,r.uvs),Jn(t,r.positions)}destroy(){for(const t in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[t].renderable);this._tilingSpriteDataHash=null,this._renderer=null}_updateCanBatch(t){const e=this._getTilingSpriteData(t),r=t.texture;let s=!0;return this._renderer.type===bt.WEBGL&&(s=this._renderer.context.supports.nonPowOf2wrapping),e.canBatch=r.textureMatrix.isSimple&&(s||r.source.isPowerOfTwo),e.canBatch}}Ms.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"tilingSprite"};const we={test(i){return typeof i=="string"&&i.startsWith("info face=")},parse(i){const t=i.match(/^[a-z]+\s+.+$/gm),e={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const u in t){const d=t[u].match(/^[a-z]+/gm)[0],f=t[u].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),p={};for(const m in f){const g=f[m].split("="),_=g[0],x=g[1].replace(/"/gm,""),y=parseFloat(x),b=isNaN(y)?x:y;p[_]=b}e[d].push(p)}const r={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[s]=e.info,[n]=e.common,[a]=e.distanceField??[];a&&(r.distanceField={range:parseInt(a.distanceRange,10),type:a.fieldType}),r.fontSize=parseInt(s.size,10),r.fontFamily=s.face,r.lineHeight=parseInt(n.lineHeight,10);const o=e.page;for(let u=0;u<o.length;u++)r.pages.push({id:parseInt(o[u].id,10)||0,file:o[u].file});const h={};r.baseLineOffset=r.lineHeight-parseInt(n.base,10);const l=e.char;for(let u=0;u<l.length;u++){const d=l[u],f=parseInt(d.id,10);let p=d.letter??d.char??String.fromCharCode(f);p==="space"&&(p=" "),h[f]=p,r.chars[p]={id:f,page:parseInt(d.page,10)||0,x:parseInt(d.x,10),y:parseInt(d.y,10),width:parseInt(d.width,10),height:parseInt(d.height,10),xOffset:parseInt(d.xoffset,10),yOffset:parseInt(d.yoffset,10),xAdvance:parseInt(d.xadvance,10),kerning:{}}}const c=e.kerning||[];for(let u=0;u<c.length;u++){const d=parseInt(c[u].first,10),f=parseInt(c[u].second,10),p=parseInt(c[u].amount,10);r.chars[h[f]].kerning[h[d]]=p}return r}},Cr={test(i){const t=i;return typeof t!="string"&&"getElementsByTagName"in t&&t.getElementsByTagName("page").length&&t.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(i){const t={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},e=i.getElementsByTagName("info")[0],r=i.getElementsByTagName("common")[0],s=i.getElementsByTagName("distanceField")[0];s&&(t.distanceField={type:s.getAttribute("fieldType"),range:parseInt(s.getAttribute("distanceRange"),10)});const n=i.getElementsByTagName("page"),a=i.getElementsByTagName("char"),o=i.getElementsByTagName("kerning");t.fontSize=parseInt(e.getAttribute("size"),10),t.fontFamily=e.getAttribute("face"),t.lineHeight=parseInt(r.getAttribute("lineHeight"),10);for(let l=0;l<n.length;l++)t.pages.push({id:parseInt(n[l].getAttribute("id"),10)||0,file:n[l].getAttribute("file")});const h={};t.baseLineOffset=t.lineHeight-parseInt(r.getAttribute("base"),10);for(let l=0;l<a.length;l++){const c=a[l],u=parseInt(c.getAttribute("id"),10);let d=c.getAttribute("letter")??c.getAttribute("char")??String.fromCharCode(u);d==="space"&&(d=" "),h[u]=d,t.chars[d]={id:u,page:parseInt(c.getAttribute("page"),10)||0,x:parseInt(c.getAttribute("x"),10),y:parseInt(c.getAttribute("y"),10),width:parseInt(c.getAttribute("width"),10),height:parseInt(c.getAttribute("height"),10),xOffset:parseInt(c.getAttribute("xoffset"),10),yOffset:parseInt(c.getAttribute("yoffset"),10),xAdvance:parseInt(c.getAttribute("xadvance"),10),kerning:{}}}for(let l=0;l<o.length;l++){const c=parseInt(o[l].getAttribute("first"),10),u=parseInt(o[l].getAttribute("second"),10),d=parseInt(o[l].getAttribute("amount"),10);t.chars[h[u]].kerning[h[c]]=d}return t}},Mr={test(i){return typeof i=="string"&&i.includes("<font>")?Cr.test(q.get().parseXML(i)):!1},parse(i){return Cr.parse(q.get().parseXML(i))}};class ks extends os{constructor(t,e){super();const{textures:r,data:s}=t;Object.keys(s.pages).forEach(n=>{const a=s.pages[parseInt(n,10)],o=r[a.id];this.pages.push({texture:o})}),Object.keys(s.chars).forEach(n=>{const a=s.chars[n],{frame:o,source:h}=r[a.page],l=new Q(a.x+o.x,a.y+o.y,a.width,a.height),c=new O({source:h,frame:l});this.chars[n]={id:n.codePointAt(0),xOffset:a.xOffset,yOffset:a.yOffset,xAdvance:a.xAdvance,kerning:a.kerning??{},texture:c}}),this.baseRenderedFontSize=s.fontSize,this.baseMeasurementFontSize=s.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:s.fontSize},this.baseLineOffset=s.baseLineOffset,this.lineHeight=s.lineHeight,this.fontFamily=s.fontFamily,this.distanceField=s.distanceField??{type:"none",range:0},this.url=e}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{texture:e}=this.pages[t];e.destroy(!0)}this.pages=null}static install(t){Ae.install(t)}static uninstall(t){Ae.uninstall(t)}}const ra=[".xml",".fnt"],sa={extension:R.CacheParser,test:i=>i instanceof ks,getCacheableAssets(i,t){const e={};return i.forEach(r=>{e[r]=t}),e[`${t.fontFamily}-bitmap`]=t,e}},ia={extension:{type:R.LoadParser,priority:$s.Normal},test(i){return ra.includes(Jt.extname(i).toLowerCase())},async testParse(i){return we.test(i)||Mr.test(i)},async parse(i,t,e){const r=we.test(i)?we.parse(i):Mr.parse(i),{src:s}=t,{pages:n}=r,a=[];for(let c=0;c<n.length;++c){const u=n[c].file;let d=Jt.join(Jt.dirname(s),u);d=Vs(d,s),a.push(d)}const o=await e.load(a),h=a.map(c=>o[c]);return new ks({data:r,textures:h},s)},async load(i,t){return await(await q.get().fetch(i)).text()},async unload(i,t,e){await Promise.all(i.pages.map(r=>e.unload(r.texture.source._sourceOrigin))),i.destroy()}},na={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `}},aa={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:` 
            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `}},oa={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}},ha={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}};class ca extends Kt{constructor(){const t=new gt({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new V,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),e=St(),r=gs({name:"sdf-shader",bits:[Dn,On(e),na,oa,xs]}),s=ms({name:"sdf-shader",bits:[Wn,Vn(e),aa,ha,_s]});super({glProgram:s,gpuProgram:r,resources:{localUniforms:t,batchSamplers:Nn(e)}})}}class Bs{constructor(t){this._gpuBitmapText={},this._renderer=t}validateRenderable(t){const e=this._getGpuBitmapText(t);return t._didTextUpdate&&(t._didTextUpdate=!1,this._updateContext(t,e)),this._renderer.renderPipes.graphics.validateRenderable(e)}addRenderable(t,e){const r=this._getGpuBitmapText(t);kr(t,r),t._didTextUpdate&&(t._didTextUpdate=!1,this._updateContext(t,r)),this._renderer.renderPipes.graphics.addRenderable(r,e),r.context.customShader&&this._updateDistanceField(t)}destroyRenderable(t){this._destroyRenderableByUid(t.uid)}_destroyRenderableByUid(t){W.return(this._gpuBitmapText[t]),this._gpuBitmapText[t]=null}updateRenderable(t){const e=this._getGpuBitmapText(t);kr(t,e),this._renderer.renderPipes.graphics.updateRenderable(e),e.context.customShader&&this._updateDistanceField(t)}_updateContext(t,e){var f;const{context:r}=e,s=Ae.getFont(t.text,t._style);r.clear(),s.distanceField.type!=="none"&&(r.customShader||(this._sdfShader||(this._sdfShader=new ca),r.customShader=this._sdfShader));const n=Array.from(t.text),a=t._style;let o=(((f=a._stroke)==null?void 0:f.width)||0)/2;o+=s.baseLineOffset;const h=cs(n,a,s);let l=0;const c=a.padding,u=h.scale;r.translate(-t._anchor._x*h.width-c,-t._anchor._y*(h.height+h.offsetY)-c).scale(u,u);const d=a._fill.color;for(let p=0;p<h.lines.length;p++){const m=h.lines[p];for(let g=0;g<m.charPositions.length;g++){const _=n[l++],x=s.chars[_];x!=null&&x.texture&&r.texture(x.texture,d||"black",Math.round(m.charPositions[g]+x.xOffset),Math.round(o+x.yOffset))}o+=s.lineHeight}}_getGpuBitmapText(t){return this._gpuBitmapText[t.uid]||this.initGpuText(t)}initGpuText(t){const e=W.get(jt);return this._gpuBitmapText[t.uid]=e,this._updateContext(t,e),t.on("destroyed",()=>{this.destroyRenderable(t)}),this._gpuBitmapText[t.uid]}_updateDistanceField(t){const e=this._getGpuBitmapText(t).context,r=t._style.fontFamily,s=X.get(`${r}-bitmap`),{a:n,b:a,c:o,d:h}=t.groupTransform,l=Math.sqrt(n*n+a*a),c=Math.sqrt(o*o+h*h),u=(Math.abs(l)+Math.abs(c))/2,d=s.baseRenderedFontSize/t._style.fontSize,f=t.resolution??this._renderer.resolution,p=u*s.distanceField.range*(1/d)*f;e.customShader.resources.localUniforms.uniforms.uDistance=p}destroy(){var t;for(const e in this._gpuBitmapText)this._destroyRenderableByUid(e);this._gpuBitmapText=null,(t=this._sdfShader)==null||t.destroy(!0),this._sdfShader=null,this._renderer=null}}Bs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"bitmapText"};function kr(i,t){t.groupTransform=i.groupTransform,t.groupColorAlpha=i.groupColorAlpha,t.groupColor=i.groupColor,t.groupBlendMode=i.groupBlendMode,t.globalDisplayStatus=i.globalDisplayStatus,t.groupTransform=i.groupTransform,t.localDisplayStatus=i.localDisplayStatus,t.groupAlpha=i.groupAlpha,t._roundPixels=i._roundPixels}class As{constructor(t){this._gpuText=Object.create(null),this._renderer=t}validateRenderable(t){const e=this._getGpuText(t),r=t._getKey();return e.textureNeedsUploading?(e.textureNeedsUploading=!1,!0):e.currentKey!==r}addRenderable(t){const r=this._getGpuText(t).batchableSprite;t._didTextUpdate&&this._updateText(t),this._renderer.renderPipes.batch.addToBatch(r)}updateRenderable(t){const r=this._getGpuText(t).batchableSprite;t._didTextUpdate&&this._updateText(t),r.batcher.updateElement(r)}destroyRenderable(t){this._destroyRenderableById(t.uid)}_destroyRenderableById(t){const e=this._gpuText[t];this._renderer.htmlText.decreaseReferenceCount(e.currentKey),W.return(e.batchableSprite),this._gpuText[t]=null}_updateText(t){const e=t._getKey(),r=this._getGpuText(t),s=r.batchableSprite;r.currentKey!==e&&this._updateGpuText(t).catch(a=>{console.error(a)}),t._didTextUpdate=!1;const n=t._style.padding;Te(s.bounds,t._anchor,s.texture,n)}async _updateGpuText(t){t._didTextUpdate=!1;const e=this._getGpuText(t);if(e.generatingTexture)return;const r=t._getKey();this._renderer.htmlText.decreaseReferenceCount(e.currentKey),e.generatingTexture=!0,e.currentKey=r;const s=t.resolution??this._renderer.resolution,n=await this._renderer.htmlText.getManagedTexture(t.text,s,t._style,t._getKey()),a=e.batchableSprite;a.texture=e.texture=n,e.generatingTexture=!1,e.textureNeedsUploading=!0,t.onViewUpdate();const o=t._style.padding;Te(a.bounds,t._anchor,a.texture,o)}_getGpuText(t){return this._gpuText[t.uid]||this.initGpuText(t)}initGpuText(t){const e={texture:O.EMPTY,currentKey:"--",batchableSprite:W.get(ys),textureNeedsUploading:!1,generatingTexture:!1},r=e.batchableSprite;return r.renderable=t,r.texture=O.EMPTY,r.bounds={minX:0,maxX:1,minY:0,maxY:0},r.roundPixels=this._renderer._roundPixels|t._roundPixels,this._gpuText[t.uid]=e,t.on("destroyed",()=>{this.destroyRenderable(t)}),e}destroy(){for(const t in this._gpuText)this._destroyRenderableById(t);this._gpuText=null,this._renderer=null}}As.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"htmlText"};function la(){const{userAgent:i}=q.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(i)}const ua=new Gt;function Fs(i,t,e,r){const s=ua;s.minX=0,s.minY=0,s.maxX=i.width/r|0,s.maxY=i.height/r|0;const n=tt.getOptimalTexture(s.width,s.height,r,!1);return n.source.uploadMethodId="image",n.source.resource=i,n.source.alphaMode="premultiply-alpha-on-upload",n.frame.width=t/r,n.frame.height=e/r,n.source.emit("update",n.source),n.updateUvs(),n}function da(i,t){const e=t.fontFamily,r=[],s={},n=/font-family:([^;"\s]+)/g,a=i.match(n);function o(h){s[h]||(r.push(h),s[h]=!0)}if(Array.isArray(e))for(let h=0;h<e.length;h++)o(e[h]);else o(e);a&&a.forEach(h=>{const l=h.split(":")[1].trim();o(l)});for(const h in t.tagStyles){const l=t.tagStyles[h].fontFamily;o(l)}return r}async function fa(i){const e=await(await q.get().fetch(i)).blob(),r=new FileReader;return await new Promise((n,a)=>{r.onloadend=()=>n(r.result),r.onerror=a,r.readAsDataURL(e)})}async function Br(i,t){const e=await fa(t);return`@font-face {
        font-family: "${i.fontFamily}";
        src: url('${e}');
        font-weight: ${i.fontWeight};
        font-style: ${i.fontStyle};
    }`}const Vt=new Map;async function pa(i,t,e){const r=i.filter(s=>X.has(`${s}-and-url`)).map((s,n)=>{if(!Vt.has(s)){const{url:a}=X.get(`${s}-and-url`);n===0?Vt.set(s,Br(t,a)):Vt.set(s,Br({fontWeight:e.fontWeight,fontStyle:e.fontStyle,fontFamily:s},a))}return Vt.get(s)});return(await Promise.all(r)).join(`
`)}function ga(i,t,e,r,s){const{domElement:n,styleElement:a,svgRoot:o}=s;n.innerHTML=`<style>${t.cssStyle}</style><div>${i}</div>`,n.setAttribute("style",`transform: scale(${e});transform-origin: top left; display: inline-block`),a.textContent=r;const{width:h,height:l}=s.image;return o.setAttribute("width",h.toString()),o.setAttribute("height",l.toString()),new XMLSerializer().serializeToString(o)}function ma(i,t){const e=ft.getOptimalCanvasAndContext(i.width,i.height,t),{context:r}=e;return r.clearRect(0,0,i.width,i.height),r.drawImage(i,0,0),ft.returnCanvasAndContext(e),e.canvas}function xa(i,t,e){return new Promise(async r=>{e&&await new Promise(s=>setTimeout(s,100)),i.onload=()=>{r()},i.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(t)}`,i.crossOrigin="anonymous"})}class Ye{constructor(t){this._activeTextures={},this._renderer=t,this._createCanvas=t.type===bt.WEBGPU}getTexture(t){return this._buildTexturePromise(t.text,t.resolution,t.style)}getManagedTexture(t,e,r,s){if(this._activeTextures[s])return this._increaseReferenceCount(s),this._activeTextures[s].promise;const n=this._buildTexturePromise(t,e,r).then(a=>(this._activeTextures[s].texture=a,a));return this._activeTextures[s]={texture:null,promise:n,usageCount:1},n}async _buildTexturePromise(t,e,r){const s=W.get(ds),n=da(t,r),a=await pa(n,r,Ve.defaultTextStyle),o=Tn(t,r,a,s),h=Math.ceil(Math.ceil(Math.max(1,o.width)+r.padding*2)*e),l=Math.ceil(Math.ceil(Math.max(1,o.height)+r.padding*2)*e),c=s.image;c.width=h|0,c.height=l|0;const u=ga(t,r,e,a,s);await xa(c,u,la()&&n.length>0);let d=c;this._createCanvas&&(d=ma(c,e));const f=Fs(d,c.width,c.height,e);return this._createCanvas&&this._renderer.texture.initSource(f.source),W.return(s),f}_increaseReferenceCount(t){this._activeTextures[t].usageCount++}decreaseReferenceCount(t){const e=this._activeTextures[t];e&&(e.usageCount--,e.usageCount===0&&(e.texture?this._cleanUp(e):e.promise.then(r=>{e.texture=r,this._cleanUp(e)}).catch(()=>{at("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[t]=null))}_cleanUp(t){tt.returnTexture(t.texture),t.texture.source.resource=null,t.texture.source.uploadMethodId="unknown"}getReferenceCount(t){return this._activeTextures[t].usageCount}destroy(){this._activeTextures=null}}Ye.extension={type:[R.WebGLSystem,R.WebGPUSystem,R.CanvasSystem],name:"htmlText"};Ye.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"};class Rs{constructor(t){this._gpuText=Object.create(null),this._renderer=t}validateRenderable(t){const e=this._getGpuText(t),r=t._getKey();if(e.currentKey!==r){const s=t.resolution??this._renderer.resolution,{width:n,height:a}=this._renderer.canvasText.getTextureSize(t.text,s,t._style);return!(this._renderer.canvasText.getReferenceCount(e.currentKey)===1&&n===e.texture._source.width&&a===e.texture._source.height)}return!1}addRenderable(t,e){const s=this._getGpuText(t).batchableSprite;t._didTextUpdate&&this._updateText(t),this._renderer.renderPipes.batch.addToBatch(s)}updateRenderable(t){const r=this._getGpuText(t).batchableSprite;t._didTextUpdate&&this._updateText(t),r.batcher.updateElement(r)}destroyRenderable(t){this._destroyRenderableById(t.uid)}_destroyRenderableById(t){const e=this._gpuText[t];this._renderer.canvasText.decreaseReferenceCount(e.currentKey),W.return(e.batchableSprite),this._gpuText[t]=null}_updateText(t){const e=t._getKey(),r=this._getGpuText(t),s=r.batchableSprite;r.currentKey!==e&&this._updateGpuText(t),t._didTextUpdate=!1;const n=t._style.padding;Te(s.bounds,t._anchor,s.texture,n)}_updateGpuText(t){const e=this._getGpuText(t),r=e.batchableSprite;e.texture&&this._renderer.canvasText.decreaseReferenceCount(e.currentKey),e.texture=r.texture=this._renderer.canvasText.getManagedTexture(t),e.currentKey=t._getKey(),r.texture=e.texture}_getGpuText(t){return this._gpuText[t.uid]||this.initGpuText(t)}initGpuText(t){const e={texture:null,currentKey:"--",batchableSprite:W.get(ys)};return e.batchableSprite.renderable=t,e.batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},e.batchableSprite.roundPixels=this._renderer._roundPixels|t._roundPixels,this._gpuText[t.uid]=e,this._updateText(t),t.on("destroyed",()=>{this.destroyRenderable(t)}),e}destroy(){for(const t in this._gpuText)this._destroyRenderableById(t);this._gpuText=null,this._renderer=null}}Rs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"text"};function Ar(i,t,e){for(let r=0,s=4*e*t;r<t;++r,s+=4)if(i[s+3]!==0)return!1;return!0}function Fr(i,t,e,r,s){const n=4*t;for(let a=r,o=r*n+4*e;a<=s;++a,o+=n)if(i[o+3]!==0)return!1;return!0}function _a(i,t=1){const{width:e,height:r}=i,s=i.getContext("2d",{willReadFrequently:!0});if(s===null)throw new TypeError("Failed to get canvas 2D context");const a=s.getImageData(0,0,e,r).data;let o=0,h=0,l=e-1,c=r-1;for(;h<r&&Ar(a,e,h);)++h;if(h===r)return Q.EMPTY;for(;Ar(a,e,c);)--c;for(;Fr(a,e,o,h,c);)++o;for(;Fr(a,e,l,h,c);)--l;return++l,++c,new Q(o/t,h/t,(l-o)/t,(c-h)/t)}class Is{constructor(t){this._activeTextures={},this._renderer=t}getTextureSize(t,e,r){const s=et.measureText(t||" ",r);let n=Math.ceil(Math.ceil(Math.max(1,s.width)+r.padding*2)*e),a=Math.ceil(Math.ceil(Math.max(1,s.height)+r.padding*2)*e);return n=Math.ceil(n-1e-6),a=Math.ceil(a-1e-6),n=yt(n),a=yt(a),{width:n,height:a}}getTexture(t,e,r,s){typeof t=="string"&&(E("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),t={text:t,style:r,resolution:e}),t.style instanceof Tt||(t.style=new Tt(t.style));const{texture:n,canvasAndContext:a}=this.createTextureAndCanvas(t);return this._renderer.texture.initSource(n._source),ft.returnCanvasAndContext(a),n}createTextureAndCanvas(t){const{text:e,style:r}=t,s=t.resolution??this._renderer.resolution,n=et.measureText(e||" ",r),a=Math.ceil(Math.ceil(Math.max(1,n.width)+r.padding*2)*s),o=Math.ceil(Math.ceil(Math.max(1,n.height)+r.padding*2)*s),h=ft.getOptimalCanvasAndContext(a,o),{canvas:l}=h;this.renderTextToCanvas(e,r,s,h);const c=Fs(l,a,o,s);if(r.trim){const u=_a(l,s);c.frame.copyFrom(u),c.updateUvs()}return{texture:c,canvasAndContext:h}}getManagedTexture(t){const e=t._getKey();if(this._activeTextures[e])return this._increaseReferenceCount(e),this._activeTextures[e].texture;const{texture:r,canvasAndContext:s}=this.createTextureAndCanvas(t);return this._activeTextures[e]={canvasAndContext:s,texture:r,usageCount:1},r}_increaseReferenceCount(t){this._activeTextures[t].usageCount++}decreaseReferenceCount(t){const e=this._activeTextures[t];if(e.usageCount--,e.usageCount===0){ft.returnCanvasAndContext(e.canvasAndContext),tt.returnTexture(e.texture);const r=e.texture.source;r.resource=null,r.uploadMethodId="unknown",r.alphaMode="no-premultiply-alpha",this._activeTextures[t]=null}}getReferenceCount(t){return this._activeTextures[t].usageCount}renderTextToCanvas(t,e,r,s){var y,b,P,k,T;const{canvas:n,context:a}=s,o=Yt(e),h=et.measureText(t||" ",e),l=h.lines,c=h.lineHeight,u=h.lineWidths,d=h.maxLineWidth,f=h.fontProperties,p=n.height;a.resetTransform(),a.scale(r,r);const m=e.padding*2;if(a.clearRect(0,0,h.width+4+m,h.height+4+m),(y=e._stroke)!=null&&y.width){const v=e._stroke;a.lineWidth=v.width,a.miterLimit=v.miterLimit,a.lineJoin=v.join,a.lineCap=v.cap}a.font=o;let g,_;const x=e.dropShadow?2:1;for(let v=0;v<x;++v){const S=e.dropShadow&&v===0,w=S?Math.ceil(Math.max(1,p)+e.padding*2):0,G=w*r;if(S){a.fillStyle="black",a.strokeStyle="black";const C=e.dropShadow,I=C.color,U=C.alpha;a.shadowColor=H.shared.setValue(I).setAlpha(U).toRgbaString();const j=C.blur*r,Pt=C.distance*r;a.shadowBlur=j,a.shadowOffsetX=Math.cos(C.angle)*Pt,a.shadowOffsetY=Math.sin(C.angle)*Pt+G}else a.globalAlpha=((b=e._fill)==null?void 0:b.alpha)??1,a.fillStyle=e._fill?Xt(e._fill,a):null,(P=e._stroke)!=null&&P.width&&(a.strokeStyle=Xt(e._stroke,a)),a.shadowColor="black";let Y=(c-f.fontSize)/2;c-f.fontSize<0&&(Y=0);const B=((k=e._stroke)==null?void 0:k.width)??0;for(let C=0;C<l.length;C++)g=B/2,_=B/2+C*c+f.ascent+Y,e.align==="right"?g+=d-u[C]:e.align==="center"&&(g+=(d-u[C])/2),(T=e._stroke)!=null&&T.width&&this._drawLetterSpacing(l[C],e,s,g+e.padding,_+e.padding-w,!0),e._fill!==void 0&&this._drawLetterSpacing(l[C],e,s,g+e.padding,_+e.padding-w)}}_drawLetterSpacing(t,e,r,s,n,a=!1){const{context:o}=r,h=e.letterSpacing;let l=!1;if(et.experimentalLetterSpacingSupported&&(et.experimentalLetterSpacing?(o.letterSpacing=`${h}px`,o.textLetterSpacing=`${h}px`,l=!0):(o.letterSpacing="0px",o.textLetterSpacing="0px")),h===0||l){a?o.strokeText(t,s,n):o.fillText(t,s,n);return}let c=s;const u=et.graphemeSegmenter(t);let d=o.measureText(t).width,f=0;for(let p=0;p<u.length;++p){const m=u[p];a?o.strokeText(m,c,n):o.fillText(m,c,n);let g="";for(let _=p+1;_<u.length;++_)g+=u[_];f=o.measureText(g).width,c+=d-f+h,d=f}}destroy(){this._activeTextures=null}}Is.extension={type:[R.WebGLSystem,R.WebGPUSystem,R.CanvasSystem],name:"canvasText"};N.add(Hr);N.add(Or);N.add(bs);N.add(We);N.add(Ts);N.add(Is);N.add(Rs);N.add(Bs,ia,sa);N.add(Ye);N.add(As);N.add(Ms);N.add(Cs);N.add(rs);N.add(ts);
